/**
 * Flowtype definitions for vscode-languageserver
 * Originally Generated by Flowgen from a Typescript Definition
 */
import type {
  Diagnostic,
  Position,
  TextDocumentChangeEvent,
  TextDocumentWillSaveEvent,
  RequestHandler,
  TextEdit,
  TextDocument,
  NotificationType,
  NotificationType0,
  RequestType,
  RequestType0,
  RPCMessageType,
  ApplyWorkspaceEditResponse,
  RequestHandler0,
  GenericRequestHandler,
  CancellationToken,
  NotificationHandler,
  NotificationHandler0,
  GenericNotificationHandler,
  InitializeParams,
  InitializeResult,
  InitializedParams,
  CompletionItem,
  CompletionList,
  SignatureHelp,
  Definition,
  DocumentHighlight,
  DocumentSymbolParams,
  SymbolInformation,
  WorkspaceSymbolParams,
  CodeActionParams,
  Command,
  CodeLensParams,
  CodeLens,
  DocumentFormattingParams,
  DocumentRangeFormattingParams,
  WorkspaceEdit,
  InitializeError,
  DidChangeWatchedFilesParams,
  Hover,
  ReferenceParams,
  DocumentOnTypeFormattingParams,
  RenameParams,
  DocumentLinkParams,
  DocumentLink,
  ExecuteCommandParams,
} from 'vscode-languageserver-types';

declare module 'vscode-languageserver' {
  declare var uriToFilePath: typeof undefined;

  declare var resolveGlobalNodePath: typeof undefined;

  declare var resolve: typeof undefined;

  declare var resolveModule: typeof undefined;

  declare var resolveModule2: typeof undefined;

  declare var resolveModulePath: typeof undefined;

  declare var TextDocumentSyncKind: {
    None: 0,
    Full: 1,
    Incremental: 2,
  };

  declare type TextDocumentSyncKindType = 0 | 1 | 2;

  /**
   * A manager for simple text documents
   */
  declare class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(): this,

    /**
     * Returns the [TextDocumentSyncKind](#TextDocumentSyncKind) used by
     * this text document manager.
     */
    syncKind: TextDocumentSyncKindType,

    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    onDidChangeContent: ((e: TextDocumentChangeEvent) => void) => void,

    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    onDidOpen: Event<TextDocumentChangeEvent>,

    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    onWillSave: Event<TextDocumentWillSaveEvent>,

    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(
      handler: RequestHandler<TextDocumentWillSaveEvent, TextEdit[], void>,
    ): void,

    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    onDidSave: Event<TextDocumentChangeEvent>,

    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    onDidClose: Event<TextDocumentChangeEvent>,

    /**
       * Returns the document for the given URI. Returns undefined if
       * the document is not mananged by this instance.
       * @param uri The text document's URI to retrieve.
       * @return  the text document or `undefined`.
       */
    get(uri: string): TextDocument,

    /**
       * Returns all text documents managed by this instance.
       * @return  all text documents.
       */
    all(): TextDocument[],

    /**
       * Returns the URIs of all text documents managed by this instance.
       * @return  the URI's of all text documents.
       */
    keys(): string[],

    /**
       * Listens for `low level` notification on the given connection to
       * update the text documents managed by this instance.
       * @param connection The connection to listen on.
       */
    listen(connection: IConnection): void,
  }
  /**
   * Helps tracking error message. Equal occurences of the same
   * message are only stored once. This class is for example
  usefull if text documents are validated in a loop and equal
  error message should be folded into one.
  */
  declare class ErrorMessageTracker {
    constructor(): this,

    /**
       * Add a message to the tracker.
       * @param message The message to add.
       */
    add(message: string): void,

    /**
       * Send all tracked messages to the conenction's window.
       * @param connection The connection establised between client and server.
       */
    sendErrors(connection: {
      window: RemoteWindow,
    }): void,
  }
  /**
   * The RemoteConsole interface contains all functions to interact with
   * the developer console of VS Code.
   */
  declare interface RemoteConsole {
    /**
       * Show an error message.
       * @param message The message to show.
       */
    error(message: string): void,

    /**
           * Show a warning message.
           * @param message The message to show.
           */
    warn(message: string): void,

    /**
           * Show an information message.
           * @param message The message to show.
           */
    info(message: string): void,

    /**
           * Log a message.
           * @param message The message to log.
           */
    log(message: string): void,
  }
  /**
   * The RemoteWindow interface contains all functions to interact with
   * the visual window of VS Code.
   */
  declare interface RemoteWindow {
    /**
       * Show an error message.
       * @param message The message to show.
       */
    showErrorMessage(message: string): void,
    showErrorMessage<T>(message: string, ...actions: T[]): Thenable<T>,

    /**
           * Show a warning message.
           * @param message The message to show.
           */
    showWarningMessage(message: string): void,
    showWarningMessage<T>(message: string, ...actions: T[]): Thenable<T>,

    /**
           * Show an information message.
           * @param message The message to show.
           */
    showInformationMessage(message: string): void,
    showInformationMessage<T>(message: string, ...actions: T[]): Thenable<T>,
  }
  /**
   * A bulk registration manages n single registration to be able to register
   * for n notifications or requests using one register request.
   */
  declare interface BulkRegistration {
    /**
       * Adds a single registration.
       * @param type the notification type to register for.
       * @param registerParams special registration parameters.
       */
    add<RO>(type: NotificationType0<RO>, registerParams: RO): void,
    add<P, RO>(type: NotificationType<P, RO>, registerParams: RO): void,

    /**
           * Adds a single registration.
           * @param type the request type to register for.
           * @param registerParams special registration parameters.
           */
    add<R, E, RO>(type: RequestType0<R, E, RO>, registerParams: RO): void,
    add<P, R, E, RO>(type: RequestType<P, R, E, RO>, registerParams: RO): void,
  }

  /**
   * Creates a new bulk registration.
   * @return  an empty bulk registration.
   */
  declare function BulkRegistration$create(): BulkRegistration;
  /**
   * A `BulkUnregistration` manages n unregistrations.
   */
  declare type BulkUnregistration = {
    /**
       * Disposes a single registration. It will be removed from the
       * `BulkUnregistration`.
       */
    disposeSingle(arg: string | RPCMessageType): boolean,
  } & Disposable;

  declare var npm$namespace$BulkRegistration: {
    create: typeof BulkRegistration$create,
  };

  /**
   * Creates a new bulk registration.
   * @return  an empty bulk registration.
   */
  declare function BulkUnregistration$create(): BulkRegistration;

  declare var npm$namespace$BulkUnregistration: {
    create: typeof BulkUnregistration$create,
  };

  /**
   * Interface to register and unregister `listeners` on the client / tools side.
   */
  declare interface RemoteClient {
    /**
       * Registers a listener for the given notification.
       * @param type the notification type to register for.
       * @param registerParams special registration parameters.
       * @return  a `Disposable` to unregister the listener again.
       */
    register<RO>(
      type: NotificationType0<RO>,
      registerParams?: RO,
    ): Thenable<Disposable>,
    register<P, RO>(
      type: NotificationType<P, RO>,
      registerParams?: RO,
    ): Thenable<Disposable>,

    /**
           * Registers a listener for the given notification.
           * @param unregisteration the unregistration to add a corresponding unregister action to.
           * @param type the notification type to register for.
           * @param registerParams special registration parameters.
           * @return  the updated unregistration.
           */
    register<RO>(
      unregisteration: BulkUnregistration,
      type: NotificationType0<RO>,
      registerParams?: RO,
    ): Thenable<BulkUnregistration>,
    register<P, RO>(
      unregisteration: BulkUnregistration,
      type: NotificationType<P, RO>,
      registerParams?: RO,
    ): Thenable<BulkUnregistration>,

    /**
           * Registers a listener for the given request.
           * @param type the request type to register for.
           * @param registerParams special registration parameters.
           * @return  a `Disposable` to unregister the listener again.
           */
    register<R, E, RO>(
      type: RequestType0<R, E, RO>,
      registerParams?: RO,
    ): Thenable<Disposable>,
    register<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      registerParams?: RO,
    ): Thenable<Disposable>,

    /**
           * Registers a listener for the given request.
           * @param unregisteration the unregistration to add a corresponding unregister action to.
           * @param type the request type to register for.
           * @param registerParams special registration parameters.
           * @return  the updated unregistration.
           */
    register<R, E, RO>(
      unregisteration: BulkUnregistration,
      type: RequestType0<R, E, RO>,
      registerParams?: RO,
    ): Thenable<BulkUnregistration>,
    register<P, R, E, RO>(
      unregisteration: BulkUnregistration,
      type: RequestType<P, R, E, RO>,
      registerParams?: RO,
    ): Thenable<BulkUnregistration>,

    /**
           * Registers a set of listeners.
           * @param registrations the bulk registration
           * @return  a `Disposable` to unregister the listeners again.
           */
    register(registrations: BulkRegistration): Thenable<BulkUnregistration>,
  }
  /**
   * Represents the workspace managed by the client.
   */
  declare interface RemoteWorkspace {
    /**
       * Applies a `WorkspaceEdit` to the workspace
       * @param edit the workspace edit.
       * @return  a thenable that resolves to the `ApplyWorkspaceEditResponse`.
       */
    applyEdit(edit: WorkspaceEdit): Thenable<ApplyWorkspaceEditResponse>,
  }
  /**
   * Interface to log telemetry events. The events are actually send to the client
   * and the client needs to feed the event into a propert telemetry system.
   */
  declare interface Telemetry {
    /**
       * Log the given data to telemetry.
       * @param data The data to log. Must be a JSON serializable object.
       */
    logEvent(data: any): void,
  }
  /**
   * Interface to log traces to the client. The events are sent to the client and the
   * client needs to log the trace events.
   */
  declare interface Tracer {
    /**
       * Log the given data to the trace Log
       */
    log(message: string, verbose?: string): void,
  }

  /**
   * The publish diagnostic notification's parameters.
   */
  declare interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: string,

    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[],
  }

  /**
   * Interface to describe the shape of the server connection.
   */
  declare interface IConnection {
    /**
     * Start listening on the input stream for messages to process.
     */
    listen(): void,

    /**
     * Installs a request handler described by the given [RequestType](#RequestType).
     * @param type The [RequestType](#RequestType) describing the request.
     * @param handler The handler to install
     */
    onRequest<R, E, RO>(
      type: RequestType0<R, E, RO>,
      handler: RequestHandler0<R, E>,
    ): void,
    onRequest<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      handler: RequestHandler<P, R, E>,
    ): void,

    /**
     * Installs a request handler for the given method.
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): void,

    /**
     * Send a request to the client.
     * @param type The [RequestType](#RequestType) describing the request.
     * @param params The request's parameters.
     */
    sendRequest<R, E, RO>(
      type: RequestType0<R, E, RO>,
      token?: CancellationToken,
    ): Thenable<R>,
    sendRequest<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      params: P,
      token?: CancellationToken,
    ): Thenable<R>,

    /**
     * Send a request to the client.
     * @param method The method to invoke on the client.
     * @param params The request's parameters.
     */
    sendRequest<R>(method: string, ...params: any[]): Thenable<R>,

    /**
     * Installs a notification handler described by the given [NotificationType](#NotificationType).
     * @param type The [NotificationType](#NotificationType) describing the notification.
     * @param handler The handler to install.
     */
    onNotification<RO>(
      type: NotificationType0<RO>,
      handler: NotificationHandler0,
    ): void,
    onNotification<P, RO>(
      type: NotificationType<P, RO>,
      handler: NotificationHandler<P>,
    ): void,

    /**
           * Installs a notification handler for the given method.
           * @param method The method to register a request handler for.
           * @param handler The handler to install.
           */
    onNotification(method: string, handler: GenericNotificationHandler): void,

    /**
           * Send a notification to the client.
           * @param type The [NotificationType](#NotificationType) describing the notification.
           * @param params The notification's parameters.
           */
    sendNotification<RO>(type: NotificationType0<RO>): void,
    sendNotification<P, RO>(type: NotificationType<P, RO>, params?: P): void,

    /**
           * Send a notification to the client.
           * @param method The method to invoke on the client.
           * @param params The notification's parameters.
           */
    sendNotification(method: string, ...args: any[]): void,

    /**
           * Installs a handler for the intialize request.
           * @param handler The initialize handler.
           */
    onInitialize(
      handler: RequestHandler<
        InitializeParams,
        InitializeResult,
        InitializeError
      >,
    ): void,

    /**
           * Installs a handler for the intialized notification.
           * @param handler The initialized handler.
           */
    onInitialized(handler: NotificationHandler<InitializedParams>): void,

    /**
           * Installs a handler for the shutdown request.
           * @param handler The initialize handler.
           */
    onShutdown(handler: RequestHandler0<void, void>): void,

    /**
           * Installs a handler for the exit notification.
           * @param handler The exit handler.
           */
    onExit(handler: NotificationHandler0): void,

    /**
           * A proxy interface for the language client interface to register for requests or
           * notifications.
           */
    client: RemoteClient,

    /**
           * A proxy for VSCode's development console. See [RemoteConsole](#RemoteConsole)
           */
    console: RemoteConsole,

    /**
           * A proxy for VSCode's window. See [RemoteWindow](#RemoteWindow)
           */
    window: RemoteWindow,

    /**
           * A proxy to send telemetry events to the client.
           */
    telemetry: Telemetry,

    /**
           * A proxy to send trace events to the client.
           */
    tracer: Tracer,

    /**
           * A proxy to talk to the client's workspace.
           */
    workspace: RemoteWorkspace,

    /**
     * Installs a handler for the `DidChangeConfiguration` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeConfiguration(
      handler: NotificationHandler<DidChangeConfigurationParams>,
    ): void,

    /**
     * Installs a handler for the `DidChangeWatchedFiles` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeWatchedFiles(
      handler: NotificationHandler<DidChangeWatchedFilesParams>,
    ): void,

    /**
     * Installs a handler for the `DidOpenTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidOpenTextDocument(
      handler: NotificationHandler<DidOpenTextDocumentParams>,
    ): void,

    /**
     * Installs a handler for the `DidChangeTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeTextDocument(
      handler: NotificationHandler<DidChangeTextDocumentParams>,
    ): void,

    /**
     * Installs a handler for the `DidCloseTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidCloseTextDocument(
      handler: NotificationHandler<DidCloseTextDocumentParams>,
    ): void,

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocument(
      handler: NotificationHandler<WillSaveTextDocumentParams>,
    ): void,

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocumentWaitUntil(
      handler: RequestHandler<WillSaveTextDocumentParams, TextEdit[], void>,
    ): void,

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidSaveTextDocument(
      handler: NotificationHandler<DidSaveTextDocumentParams>,
    ): void,

    /**
     * Sends diagnostics computed for a given document to VSCode to render them in the
     * user interface.
     * @param params The diagnostic parameters.
     */
    sendDiagnostics(params: PublishDiagnosticsParams): void,

    /**
     * Installs a handler for the `Hover` request.
     * @param handler The corresponding handler.
     */
    onHover(
      handler: RequestHandler<TextDocumentPositionParams, Hover, void>,
    ): void,

    /**
     * Installs a handler for the `Completion` request.
     * @param handler The corresponding handler.
     */
    onCompletion(
      handler: RequestHandler<
        TextDocumentPositionParams,
        CompletionItem[] | CompletionList,
        void
      >,
    ): void,

    /**
           * Installs a handler for the `CompletionResolve` request.
           * @param handler The corresponding handler.
           */
    onCompletionResolve(
      handler: RequestHandler<CompletionItem, CompletionItem, void>,
    ): void,

    /**
           * Installs a handler for the `SignatureHelp` request.
           * @param handler The corresponding handler.
           */
    onSignatureHelp(
      handler: RequestHandler<TextDocumentPositionParams, SignatureHelp, void>,
    ): void,

    /**
     * Installs a handler for the `Definition` request.
     * @param handler The corresponding handler.
     */
    onDefinition(
      handler: RequestHandler<TextDocumentPositionParams, Definition, void>,
    ): void,

    /**
           * Installs a handler for the `References` request.
           * @param handler The corresponding handler.
           */
    onReferences(
      handler: RequestHandler<ReferenceParams, Location[], void>,
    ): void,

    /**
           * Installs a handler for the `DocumentHighlight` request.
           * @param handler The corresponding handler.
           */
    onDocumentHighlight(
      handler: RequestHandler<
        TextDocumentPositionParams,
        DocumentHighlight[],
        void
      >,
    ): void,

    /**
     * Installs a handler for the `DocumentSymbol` request.
     * @param handler The corresponding handler.
     */
    onDocumentSymbol(
      handler: RequestHandler<DocumentSymbolParams, SymbolInformation[], void>,
    ): void,

    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbol(
      handler: RequestHandler<WorkspaceSymbolParams, SymbolInformation[], void>,
    ): void,

    /**
           * Installs a handler for the `CodeAction` request.
           * @param handler The corresponding handler.
           */
    onCodeAction(
      handler: RequestHandler<CodeActionParams, Command[], void>,
    ): void,

    /**
           * Compute a list of [lenses](#CodeLens). This call should return as fast as possible and if
           * computing the commands is expensive implementors should only return code lens objects with the
          range set and handle the resolve request.
           * @param handler The corresponding handler.
          */
    onCodeLens(handler: RequestHandler<CodeLensParams, CodeLens[], void>): void,

    /**
           * This function will be called for each visible code lens, usually when scrolling and after
           * the onCodeLens has been called.
           * @param handler The corresponding handler.
           */
    onCodeLensResolve(handler: RequestHandler<CodeLens, CodeLens, void>): void,

    /**
           * Installs a handler for the document formatting request.
           * @param handler The corresponding handler.
           */
    onDocumentFormatting(
      handler: RequestHandler<DocumentFormattingParams, TextEdit[], void>,
    ): void,

    /**
           * Installs a handler for the document range formatting request.
           * @param handler The corresponding handler.
           */
    onDocumentRangeFormatting(
      handler: RequestHandler<DocumentRangeFormattingParams, TextEdit[], void>,
    ): void,

    /**
           * Installs a handler for the document on type formatting request.
           * @param handler The corresponding handler.
           */
    onDocumentOnTypeFormatting(
      handler: RequestHandler<DocumentOnTypeFormattingParams, TextEdit[], void>,
    ): void,

    /**
           * Installs a handler for the rename request.
           * @param handler The corresponding handler.
           */
    onRenameRequest(
      handler: RequestHandler<RenameParams, WorkspaceEdit, void>,
    ): void,

    /**
           * Installs a handler for the document links request.
           * @param handler The corresponding handler.
           */
    onDocumentLinks(
      handler: RequestHandler<DocumentLinkParams, DocumentLink[], void>,
    ): void,

    /**
           * Installs a handler for the document links resolve request.
           * @param handler The corresponding handler.
           */
    onDocumentLinkResolve(
      handler: RequestHandler<DocumentLink, DocumentLink, void>,
    ): void,

    /**
           * Installs a handler for the execute command request.
           * @param handler The corresponding handler.
           */
    onExecuteCommand(
      handler: RequestHandler<ExecuteCommandParams, any, void>,
    ): void,

    /**
           * Disposes the connection
           */
    dispose(): void,
  }
  /**
   * Creates a new connection using a the given streams.
   * @param inputStream The stream to read messages from.
   * @param outputStream The stream to write messages to.
   * @return  a [connection](#IConnection)
   */
  declare function createConnection(
    inputStream: stream$Reader,
    outputStream: stream$Writer,
  ): IConnection;

  declare class IPCMessageReader extends stream$Reader {}

  declare class IPCMessageWriter extends stream$Writer {}
}

declare module 'vscode-languageserver/lib/protocol' {
  /**
   * A document filter denotes a document by different properties like
   * the [language](#TextDocument.languageId), the [scheme](#Uri.scheme) of
  its resource, or a glob-pattern that is applied to the [path](#TextDocument.fileName).
   * @sample  A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
   * @sample  A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
  */
  declare type DocumentFilter =
    | {
        /**
       * A language id, like `typescript`.
       */
        language: string,

        /**
       * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
       */
        scheme?: string,

        /**
       * A glob pattern, like `.{ts,js}`.
       */
        pattern?: string,
      }
    | {
        /**
       * A language id, like `typescript`.
       */
        language?: string,

        /**
       * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
       */
        scheme: string,

        /**
       * A glob pattern, like `.{ts,js}`.
       */
        pattern?: string,
      }
    | {
        /**
       * A language id, like `typescript`.
       */
        language?: string,

        /**
       * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
       */
        scheme?: string,

        /**
       * A glob pattern, like `.{ts,js}`.
       */
        pattern: string,
      };
  declare var npm$namespace$DocumentFilter: {
    is: typeof DocumentFilter$is,
  };
  declare function DocumentFilter$is(value: any): DocumentFilter;
  /**
   * A document selector is the combination of one or many document filters.
   * @sample  `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**∕tsconfig.json' }]`;
   */
  declare type DocumentSelector = (string | DocumentFilter)[];
  /**
   * General paramters to to regsiter for an notification or to register a provider.
   */
  declare interface Registration {
    /**
       * The id used to register the request. The id can be used to deregister
       * the request again.
       */
    id: string,

    /**
           * The method to register for.
           */
    method: string,

    /**
           * Options necessary for the registration.
           */
    registerOptions?: any,
  }
  declare interface RegistrationParams {
    registrations: Registration[],
  }
  declare var type: RequestType<RegistrationParams, void, void, void>;
  /**
   * General parameters to unregister a request or notification.
   */
  declare interface Unregistration {
    /**
       * The id used to unregister the request or notification. Usually an id
       * provided during the register request.
       */
    id: string,

    /**
           * The method to unregister for.
           */
    method: string,
  }
  declare interface UnregistrationParams {
    unregisterations: Unregistration[],
  }
  declare var type: RequestType<UnregistrationParams, void, void, void>;
  /**
   * A parameter literal used in requests to pass a text document and a position inside that
   * document.
   */
  declare interface TextDocumentPositionParams {
    /**
       * The text document.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The position inside the text document.
           */
    position: Position,
  }
  /**
   * Workspace specific client capabilities.
   */
  declare interface WorkspaceClientCapabilites {
    /**
       * The client supports applying batch edits
       * to the workspace by supporting the request
      'workspace/applyEdit'
      */
    applyEdit?: boolean,

    /**
           * Capabilities specific to `WorkspaceEdit`s
           */
    workspaceEdit?: {
      /**
               * The client supports versioned document changes in `WorkspaceEdit`s
               */
      documentChanges?: boolean,
    },

    /**
           * Capabilities specific to the `workspace/didChangeConfiguration` notification.
           */
    didChangeConfiguration?: {
      /**
               * Did change configuration notification supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
           */
    didChangeWatchedFiles?: {
      /**
               * Did change watched files notification supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `workspace/symbol` request.
           */
    symbol?: {
      /**
               * Symbol request supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `workspace/executeCommand` request.
           */
    executeCommand?: {
      /**
               * Execute command supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },
  }
  /**
   * Text document specific client capabilities.
   */
  declare interface TextDocumentClientCapabilities {
    /**
       * Defines which synchronization capabilities the client supports.
       */
    synchronization?: {
      /**
               * Whether text document synchronization supports dynamic registration.
               */
      dynamicRegistration?: boolean,

      /**
               * The client supports sending will save notifications.
               */
      willSave?: boolean,

      /**
               * The client supports sending a will save request and
               * waits for a response providing text edits which will
              be applied to the document before it is saved.
              */
      willSaveWaitUntil?: boolean,

      /**
               * The client supports did save notifications.
               */
      didSave?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/completion`
           */
    completion?: {
      /**
               * Whether completion supports dynamic registration.
               */
      dynamicRegistration?: boolean,

      /**
               * The client supports the following `CompletionItem` specific
               * capabilities.
               */
      completionItem?: {
        /**
                   * Client supports snippets as insert text.
                   *
                  A snippet can define tab stops and placeholders with `$1`, `$2`
                  and `${3:foo}`. `$0` defines the final tab stop, it defaults to
                  the end of the snippet. Placeholders with equal identifiers are linked,
                  that is typing in one will update others too.
                  */
        snippetSupport?: boolean,
      },
    },

    /**
           * Capabilities specific to the `textDocument/hover`
           */
    hover?: {
      /**
               * Whether hover supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/signatureHelp`
           */
    signatureHelp?: {
      /**
               * Whether signature help supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/references`
           */
    references?: {
      /**
               * Whether references supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/documentHighlight`
           */
    documentHighlight?: {
      /**
               * Whether document highlight supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/documentSymbol`
           */
    documentSymbol?: {
      /**
               * Whether document symbol supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/formatting`
           */
    formatting?: {
      /**
               * Whether formatting supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/rangeFormatting`
           */
    rangeFormatting?: {
      /**
               * Whether range formatting supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/onTypeFormatting`
           */
    onTypeFormatting?: {
      /**
               * Whether on type formatting supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/definition`
           */
    definition?: {
      /**
               * Whether definition supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/codeAction`
           */
    codeAction?: {
      /**
               * Whether code action supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/codeLens`
           */
    codeLens?: {
      /**
               * Whether code lens supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/documentLink`
           */
    documentLink?: {
      /**
               * Whether document link supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },

    /**
           * Capabilities specific to the `textDocument/rename`
           */
    rename?: {
      /**
               * Whether rename supports dynamic registration.
               */
      dynamicRegistration?: boolean,
    },
  }
  /**
   * Defines the capabilities provided by the client.
   */
  declare interface ClientCapabilities {
    /**
       * Workspace specific client capabilities.
       */
    workspace?: WorkspaceClientCapabilites,

    /**
           * Text document specific client capabilities.
           */
    textDocument?: TextDocumentClientCapabilities,

    /**
           * Experimental client capabilities.
           */
    experimental?: any,
  }

  /**
   * General text document registration options.
   */
  declare interface TextDocumentRegistrationOptions {
    /**
       * A document selector to identify the scope of the registration. If set to null
       * the document selector provided on the client side will be used.
       */
    documentSelector: DocumentSelector | null,
  }
  /**
   * Completion options.
   */
  declare interface CompletionOptions {
    /**
       * The server provides support to resolve additional
       * information for a completion item.
       */
    resolveProvider?: boolean,

    /**
           * The characters that trigger completion automatically.
           */
    triggerCharacters?: string[],
  }
  /**
   * Signature help options.
   */
  declare interface SignatureHelpOptions {
    /**
       * The characters that trigger signature help
       * automatically.
       */
    triggerCharacters?: string[],
  }
  /**
   * Code Lens options.
   */
  declare interface CodeLensOptions {
    /**
       * Code lens has a resolve provider as well.
       */
    resolveProvider?: boolean,
  }
  /**
   * Format document on type options
   */
  declare interface DocumentOnTypeFormattingOptions {
    /**
       * A character on which formatting should be triggered, like `}`.
       */
    firstTriggerCharacter: string,

    /**
           * More trigger characters.
           */
    moreTriggerCharacter?: string[],
  }
  /**
   * Document link options
   */
  declare interface DocumentLinkOptions {
    /**
       * Document links have a resolve provider as well.
       */
    resolveProvider?: boolean,
  }
  /**
   * Execute command options.
   */
  declare interface ExecuteCommandOptions {
    /**
       * The commands to be executed on the server
       */
    commands: string[],
  }
  /**
   * Save options.
   */
  declare interface SaveOptions {
    /**
       * The client is supposed to include the content on save.
       */
    includeText?: boolean,
  }
  declare interface TextDocumentSyncOptions {
    /**
       * Open and close notifications are sent to the server.
       */
    openClose?: boolean,

    /**
           * Change notificatins are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
           * and TextDocumentSyncKindIncremental.
           */
    change?: TextDocumentSyncKind,

    /**
           * Will save notifications are sent to the server.
           */
    willSave?: boolean,

    /**
           * Will save wait until requests are sent to the server.
           */
    willSaveWaitUntil?: boolean,

    /**
           * Save notifications are sent to the server.
           */
    save?: SaveOptions,
  }
  /**
   * Defines the capabilities provided by a language
   * server.
   */
  declare interface ServerCapabilities {
    /**
       * Defines how text documents are synced. Is either a detailed structure defining each notification or
       * for backwards compatibility the TextDocumentSyncKind number.
       */
    textDocumentSync?: TextDocumentSyncOptions | TextDocumentSyncKind,

    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean,

    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions,

    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions,

    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean,

    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean,

    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean,

    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean,

    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean,

    /**
     * The server provides code actions.
     */
    codeActionProvider?: boolean,

    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions,

    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean,

    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean,

    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: {
      /**
       * A character on which formatting should be triggered, like `}`.
       */
      firstTriggerCharacter: string,

      /**
       * More trigger characters.
       */
      moreTriggerCharacter?: string[],
    },

    /**
     * The server provides rename support.
     */
    renameProvider?: boolean,

    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions,

    /**
     * The server provides execute command support.
     */
    executeCommandProvider?: ExecuteCommandOptions,

    /**
     * Experimental server capabilities.
     */
    experimental?: any,
  }
  declare var type: RequestType<
    InitializeParams,
    InitializeResult,
    InitializeError,
    void
  >;
  /**
   * The initialize parameters
   */
  declare interface InitializeParams {
    /**
       * The process Id of the parent process that started
       * the server.
       */
    processId: number,

    /**
           * The rootPath of the workspace. Is null
           * if no folder is open.
           * @deprecated  in favour of rootUri.
           */
    rootPath?: string | null,

    /**
           * The rootUri of the workspace. Is null if no
           * folder is open. If both `rootPath` and `rootUri` are set
          `rootUri` wins.
          */
    rootUri: string | null,

    /**
           * The capabilities provided by the client (editor or tool)
           */
    capabilities: ClientCapabilities,

    /**
           * User provided initialization options.
           */
    initializationOptions?: any,

    /**
           * The initial trace setting. If omitted trace is disabled ('off').
           */
    trace?: off | messages | verbose,
  }
  /**
   * The result returned from an initilize request.
   */
  declare interface InitializeResult {
    /**
       * The capabilities the language server provides.
       */
    capabilities: ServerCapabilities,
  }
  declare var unknownProtocolVersion: number;
  /**
   * The data type of the ResponseError if the
   * initialize request fails.
   */
  declare interface InitializeError {
    /**
       * Indicates whether the client should retry to send the
       * initialize request after showing the message provided
      in the {@link ResponseError}
      */
    retry: boolean,
  }
  declare interface InitializedParams {}
  declare var type: NotificationType<InitializedParams, void>;
  declare var type: RequestType0<void, void, void>;
  declare var type: NotificationType0<void>;
  declare var type: NotificationType<DidChangeConfigurationParams, void>;
  /**
   * The parameters of a change configuration notification.
   */
  declare interface DidChangeConfigurationParams {
    /**
       * The actual changed settings
       */
    settings: any,
  }
  declare var Error: 1;

  declare var Warning: 2;

  declare var Info: 3;

  declare var Log: 4;
  declare type MessageType = 1 | 2 | 3 | 4;
  /**
   * The parameters of a notification message.
   */
  declare interface ShowMessageParams {
    /**
       * The message type. See {@link MessageType}
       */
    type: MessageType,

    /**
           * The actual message
           */
    message: string,
  }
  declare var type: NotificationType<ShowMessageParams, void>;
  declare interface MessageActionItem {
    /**
       * A short title like 'Retry', 'Open Log' etc.
       */
    title: string,
  }
  declare interface ShowMessageRequestParams {
    /**
       * The message type. See {@link MessageType}
       */
    type: MessageType,

    /**
           * The actual message
           */
    message: string,

    /**
           * The message action items to present.
           */
    actions?: MessageActionItem[],
  }
  declare var type: RequestType<
    ShowMessageRequestParams,
    MessageActionItem,
    void,
    void
  >;
  declare var type: NotificationType<LogMessageParams, void>;
  /**
   * The log message parameters.
   */
  declare interface LogMessageParams {
    /**
       * The message type. See {@link MessageType}
       */
    type: MessageType,

    /**
           * The actual message
           */
    message: string,
  }
  declare var type: NotificationType<any, void>;
  /**
   * The parameters send in a open text document notification
   */
  declare interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem,
  }
  declare var type: NotificationType<
    DidOpenTextDocumentParams,
    TextDocumentRegistrationOptions
  >;
  /**
   * The change text document notification's parameters.
   */
  declare interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier,

    /**
     * The actual content changes.
     */
    contentChanges: TextDocumentContentChangeEvent[],
  }
  /**
   * Descibe options to be used when registered for text document change events.
   */
  declare type TextDocumentChangeRegistrationOptions = {
    /**
     * How documents are synced to the server.
     */
    syncKind: TextDocumentSyncKind,
  } & TextDocumentRegistrationOptions;
  declare var type: NotificationType<
    DidChangeTextDocumentParams,
    TextDocumentChangeRegistrationOptions
  >;
  /**
   * The parameters send in a close text document notification
   */
  declare interface DidCloseTextDocumentParams {
    /**
       * The document that was closed.
       */
    textDocument: TextDocumentIdentifier,
  }
  declare var type: NotificationType<
    DidCloseTextDocumentParams,
    TextDocumentRegistrationOptions
  >;
  /**
   * The parameters send in a save text document notification
   */
  declare interface DidSaveTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: VersionedTextDocumentIdentifier,

    /**
     * Optional the content when saved. Depends on the includeText value
     * when the save notifcation was requested.
     */
    text?: string,
  }
  /**
   * Save registration options.
   */
  declare type TextDocumentSaveRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    SaveOptions;
  declare var type: NotificationType<
    DidSaveTextDocumentParams,
    TextDocumentSaveRegistrationOptions
  >;
  /**
   * The parameters send in a will save text document notification.
   */
  declare interface WillSaveTextDocumentParams {
    /**
       * The document that will be saved.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The 'TextDocumentSaveReason'.
           */
    reason: TextDocumentSaveReason,
  }
  declare var type: NotificationType<
    WillSaveTextDocumentParams,
    TextDocumentRegistrationOptions
  >;
  declare var type: RequestType<
    WillSaveTextDocumentParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare var type: NotificationType<DidChangeWatchedFilesParams, void>;
  /**
   * The watched files change notification's parameters.
   */
  declare interface DidChangeWatchedFilesParams {
    /**
       * The actual file events.
       */
    changes: FileEvent[],
  }
  declare var Created: 1;

  declare var Changed: 2;

  declare var Deleted: 3;
  declare type FileChangeType = 1 | 2 | 3;
  /**
   * An event describing a file change.
   */
  declare interface FileEvent {
    /**
       * The file's uri.
       */
    uri: string,

    /**
           * The change type.
           */
    type: FileChangeType,
  }
  declare var type: NotificationType<PublishDiagnosticsParams, void>;
  /**
   * Completion registration options.
   */
  declare type CompletionRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    CompletionOptions;
  declare var type: RequestType<
    TextDocumentPositionParams,
    CompletionList | CompletionItem[],
    void,
    CompletionRegistrationOptions
  >;
  declare var type: RequestType<CompletionItem, CompletionItem, void, void>;
  declare var type: RequestType<
    TextDocumentPositionParams,
    Hover,
    void,
    TextDocumentRegistrationOptions
  >;
  /**
   * Signature help registration options.
   */
  declare type SignatureHelpRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    SignatureHelpOptions;
  declare var type: RequestType<
    TextDocumentPositionParams,
    SignatureHelp,
    void,
    SignatureHelpRegistrationOptions
  >;
  declare var type: RequestType<
    TextDocumentPositionParams,
    Definition,
    void,
    TextDocumentRegistrationOptions
  >;
  /**
   * Parameters for a [ReferencesRequest](#ReferencesRequest).
   */
  declare type ReferenceParams = {
    context: ReferenceContext,
  } & TextDocumentPositionParams;
  declare var type: RequestType<
    ReferenceParams,
    Location[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare var type: RequestType<
    TextDocumentPositionParams,
    DocumentHighlight[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare var type: RequestType<
    DocumentSymbolParams,
    SymbolInformation[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare var type: RequestType<
    WorkspaceSymbolParams,
    SymbolInformation[],
    void,
    void
  >;
  /**
   * Params for the CodeActionRequest
   */
  declare interface CodeActionParams {
    /**
       * The document in which the command was invoked.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The range for which the command was invoked.
           */
    range: Range,

    /**
           * Context carrying additional information.
           */
    context: CodeActionContext,
  }
  declare var type: RequestType<
    CodeActionParams,
    Command[],
    void,
    TextDocumentRegistrationOptions
  >;
  /**
   * Params for the Code Lens request.
   */
  declare interface CodeLensParams {
    /**
       * The document to request code lens for.
       */
    textDocument: TextDocumentIdentifier,
  }
  /**
   * Code Lens registration options.
   */
  declare type CodeLensRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    CodeLensOptions;
  declare var type: RequestType<
    CodeLensParams,
    CodeLens[],
    void,
    CodeLensRegistrationOptions
  >;
  declare var type: RequestType<CodeLens, CodeLens, void, void>;
  declare interface DocumentFormattingParams {
    /**
       * The document to format.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The format options
           */
    options: FormattingOptions,
  }
  declare var type: RequestType<
    DocumentFormattingParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare interface DocumentRangeFormattingParams {
    /**
       * The document to format.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The range to format
           */
    range: Range,

    /**
           * The format options
           */
    options: FormattingOptions,
  }
  declare var type: RequestType<
    DocumentRangeFormattingParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions
  >;
  declare interface DocumentOnTypeFormattingParams {
    /**
       * The document to format.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The position at which this request was send.
           */
    position: Position,

    /**
           * The character that has been typed.
           */
    ch: string,

    /**
           * The format options.
           */
    options: FormattingOptions,
  }
  /**
   * Format document on type options
   */
  declare type DocumentOnTypeFormattingRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    DocumentOnTypeFormattingOptions;
  declare var type: RequestType<
    DocumentOnTypeFormattingParams,
    TextEdit[],
    void,
    DocumentOnTypeFormattingRegistrationOptions
  >;
  declare interface RenameParams {
    /**
       * The document to format.
       */
    textDocument: TextDocumentIdentifier,

    /**
           * The position at which this request was send.
           */
    position: Position,

    /**
           * The new name of the symbol. If the given name is not valid the
           * request must return a [ResponseError](#ResponseError) with an
          appropriate message set.
          */
    newName: string,
  }
  declare var type: RequestType<
    RenameParams,
    WorkspaceEdit,
    void,
    TextDocumentRegistrationOptions
  >;
  declare interface DocumentLinkParams {
    /**
       * The document to provide document links for.
       */
    textDocument: TextDocumentIdentifier,
  }
  /**
   * Document link registration options
   */
  declare type DocumentLinkRegistrationOptions = {
  } & TextDocumentRegistrationOptions &
    DocumentLinkOptions;
  declare var type: RequestType<
    DocumentLinkParams,
    DocumentLink[],
    void,
    DocumentLinkRegistrationOptions
  >;
  declare var type: RequestType<DocumentLink, DocumentLink, void, void>;
  declare interface ExecuteCommandParams {
    /**
       * The identifier of the actual command handler.
       */
    command: string,

    /**
           * Arguments that the command should be invoked with.
           */
    arguments?: any[],
  }
  /**
   * Execute command registration options.
   */
  declare type ExecuteCommandRegistrationOptions = {} & ExecuteCommandOptions;
  declare var type: RequestType<
    ExecuteCommandParams,
    any,
    void,
    ExecuteCommandRegistrationOptions
  >;
  /**
   * The parameters passed via a apply workspace edit request.
   */
  declare interface ApplyWorkspaceEditParams {
    /**
       * The edits to apply.
       */
    edit: WorkspaceEdit,
  }
  /**
   * A reponse returned from the apply workspace edit request.
   */
  declare interface ApplyWorkspaceEditResponse {
    /**
       * Indicates whether the edit was applied or not.
       */
    applied: boolean,
  }
  declare var type: RequestType<
    ApplyWorkspaceEditParams,
    ApplyWorkspaceEditResponse,
    void,
    void
  >;
}
