/**
 * Flowtype definitions for vscode-languageserver
 * Originally Generated by Flowgen from a Typescript Definition
 */
import type {
  ApplyWorkspaceEditResponse,
  CancellationToken,
  CodeActionParams,
  CodeLens,
  CodeLensParams,
  Command,
  CompletionItem,
  CompletionList,
  Definition,
  Diagnostic,
  DidChangeWatchedFilesParams,
  DocumentFormattingParams,
  DocumentHighlight,
  DocumentLink,
  DocumentLinkParams,
  DocumentOnTypeFormattingParams,
  DocumentRangeFormattingParams,
  DocumentSymbolParams,
  ExecuteCommandParams,
  GenericNotificationHandler,
  GenericRequestHandler,
  Hover,
  InitializeError,
  InitializeParams,
  InitializeResult,
  InitializedParams,
  NotificationHandler,
  NotificationHandler0,
  NotificationType,
  NotificationType0,
  Position,
  RPCMessageType,
  ReferenceParams,
  RenameParams,
  RequestHandler,
  RequestHandler0,
  RequestType,
  RequestType0,
  SignatureHelp,
  SymbolInformation,
  TextDocument,
  TextDocumentChangeEvent,
  TextDocumentContentChangeEvent,
  TextDocumentIdentifier,
  TextDocumentItem,
  TextDocumentPositionParams,
  TextDocumentSaveReasonType,
  TextDocumentWillSaveEvent,
  TextEdit,
  VersionedTextDocumentIdentifier,
  WorkspaceEdit,
  WorkspaceSymbolParams,
} from 'vscode-languageserver-types';

type Disposable = {
  dispose(): void,
};

declare module 'vscode-languageserver' {
  declare var uriToFilePath: typeof undefined;

  declare var resolveGlobalNodePath: typeof undefined;

  declare var resolve: typeof undefined;

  declare var resolveModule: typeof undefined;

  declare var resolveModule2: typeof undefined;

  declare var resolveModulePath: typeof undefined;

  declare var TextDocumentSyncKind: {
    None: 0,
    Full: 1,
    Incremental: 2,
  };

  declare type TextDocumentSyncKindType = 0 | 1 | 2;

  /**
   * A manager for simple text documents
   */
  declare class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(): this;

    /**
     * Returns the [TextDocumentSyncKind](#TextDocumentSyncKind) used by
     * this text document manager.
     */
    syncKind: TextDocumentSyncKindType;

    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    onDidChangeContent: ((e: TextDocumentChangeEvent) => void) => void;

    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    onDidOpen: Event<TextDocumentChangeEvent>;

    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    onWillSave: Event<TextDocumentWillSaveEvent>;

    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(
      handler: RequestHandler<TextDocumentWillSaveEvent, TextEdit[], void>,
    ): void;

    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    onDidSave: Event<TextDocumentChangeEvent>;

    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    onDidClose: Event<TextDocumentChangeEvent>;

    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not mananged by this instance.
     * @param uri The text document's URI to retrieve.
     * @return  the text document or `undefined`.
     */
    get(uri: string): TextDocument;

    /**
     * Returns all text documents managed by this instance.
     * @return  all text documents.
     */
    all(): TextDocument[];

    /**
     * Returns the URIs of all text documents managed by this instance.
     * @return  the URI's of all text documents.
     */
    keys(): string[];

    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     * @param connection The connection to listen on.
     */
    listen(connection: IConnection): void;
  }

  /**
   * Helps tracking error message. Equal occurences of the same
   * message are only stored once. This class is for example
   * usefull if text documents are validated in a loop and equal
   * error message should be folded into one.
   */
  declare class ErrorMessageTracker {
    constructor(): this;

    /**
     * Add a message to the tracker.
     * @param message The message to add.
     */
    add(message: string): void;

    /**
     * Send all tracked messages to the conenction's window.
     * @param connection The connection establised between client and server.
     */
    sendErrors(connection: {
      window: RemoteWindow,
    }): void;
  }

  /**
   * The RemoteConsole interface contains all functions to interact with
   * the developer console of VS Code.
   */
  declare interface RemoteConsole {
    /**
     * Show an error message.
     * @param message The message to show.
     */
    error(message: string): void;

    /**
     * Show a warning message.
     * @param message The message to show.
     */
    warn(message: string): void;

    /**
     * Show an information message.
     * @param message The message to show.
     */
    info(message: string): void;

    /**
     * Log a message.
     * @param message The message to log.
     */
    log(message: string): void;
  }
  /**
   * The RemoteWindow interface contains all functions to interact with
   * the visual window of VS Code.
   */
  declare interface RemoteWindow {
    /**
     * Show an error message.
     * @param message The message to show.
     */
    showErrorMessage(message: string): void;
    showErrorMessage<T>(message: string, ...actions: T[]): Promise<T>;

    /**
     * Show a warning message.
     * @param message The message to show.
     */
    showWarningMessage(message: string): void;
    showWarningMessage<T>(message: string, ...actions: T[]): Promise<T>;

    /**
     * Show an information message.
     * @param message The message to show.
     */
    showInformationMessage(message: string): void;
    showInformationMessage<T>(message: string, ...actions: T[]): Promise<T>;
  }
  /**
   * A bulk registration manages n single registration to be able to register
   * for n notifications or requests using one register request.
   */
  declare interface BulkRegistration {
    /**
     * Adds a single registration.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     */
    add<RO>(type: NotificationType0<RO>, registerParams: RO): void;
    add<P, RO>(type: NotificationType<P, RO>, registerParams: RO): void;

    /**
     * Adds a single registration.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     */
    add<R, E, RO>(type: RequestType0<R, E, RO>, registerParams: RO): void;
    add<P, R, E, RO>(type: RequestType<P, R, E, RO>, registerParams: RO): void;
  }

  /**
   * Creates a new bulk registration.
   * @return  an empty bulk registration.
   */
  declare function BulkRegistration$create(): BulkRegistration;
  /**
   * A `BulkUnregistration` manages n unregistrations.
   */
  declare type BulkUnregistration = {
    /**
     * Disposes a single registration. It will be removed from the
     * `BulkUnregistration`.
     */
    disposeSingle(arg: string | RPCMessageType): boolean,
  } & Disposable;

  declare var vscodeLanguageserver$BulkRegistration: {
    create: typeof BulkRegistration$create,
  };

  /**
   * Creates a new bulk registration.
   * @return  an empty bulk registration.
   */
  declare function BulkUnregistration$create(): BulkRegistration;

  declare var vscodeLanguageserver$BulkUnregistration: {
    create: typeof BulkUnregistration$create,
  };

  /**
   * Interface to register and unregister `listeners` on the client / tools side.
   */
  declare interface RemoteClient {
    /**
     * Registers a listener for the given notification.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     * @return  a `Disposable` to unregister the listener again.
     */
    register<RO>(
      type: NotificationType0<RO>,
      registerParams?: RO,
    ): Promise<Disposable>;
    register<P, RO>(
      type: NotificationType<P, RO>,
      registerParams?: RO,
    ): Promise<Disposable>;

    /**
     * Registers a listener for the given notification.
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the notification type to register for.
     * @param registerParams special registration parameters.
     * @return  the updated unregistration.
     */
    register<RO>(
      unregisteration: BulkUnregistration,
      type: NotificationType0<RO>,
      registerParams?: RO,
    ): Promise<BulkUnregistration>;
    register<P, RO>(
      unregisteration: BulkUnregistration,
      type: NotificationType<P, RO>,
      registerParams?: RO,
    ): Promise<BulkUnregistration>;

    /**
     * Registers a listener for the given request.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return  a `Disposable` to unregister the listener again.
     */
    register<R, E, RO>(
      type: RequestType0<R, E, RO>,
      registerParams?: RO,
    ): Promise<Disposable>;
    register<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      registerParams?: RO,
    ): Promise<Disposable>;

    /**
     * Registers a listener for the given request.
     * @param unregisteration the unregistration to add a corresponding unregister action to.
     * @param type the request type to register for.
     * @param registerParams special registration parameters.
     * @return  the updated unregistration.
     */
    register<R, E, RO>(
      unregisteration: BulkUnregistration,
      type: RequestType0<R, E, RO>,
      registerParams?: RO,
    ): Promise<BulkUnregistration>;
    register<P, R, E, RO>(
      unregisteration: BulkUnregistration,
      type: RequestType<P, R, E, RO>,
      registerParams?: RO,
    ): Promise<BulkUnregistration>;

    /**
     * Registers a set of listeners.
     * @param registrations the bulk registration
     * @return  a `Disposable` to unregister the listeners again.
     */
    register(registrations: BulkRegistration): Promise<BulkUnregistration>;
  }
  /**
   * Represents the workspace managed by the client.
   */
  declare interface RemoteWorkspace {
    /**
     * Applies a `WorkspaceEdit` to the workspace
     * @param edit the workspace edit.
     * @return  a Promise that resolves to the `ApplyWorkspaceEditResponse`.
     */
    applyEdit(edit: WorkspaceEdit): Promise<ApplyWorkspaceEditResponse>;
  }
  /**
   * Interface to log telemetry events. The events are actually send to the client
   * and the client needs to feed the event into a propert telemetry system.
   */
  declare interface Telemetry {
    /**
     * Log the given data to telemetry.
     * @param data The data to log. Must be a JSON serializable object.
     */
    logEvent(data: any): void;
  }
  /**
   * Interface to log traces to the client. The events are sent to the client and the
   * client needs to log the trace events.
   */
  declare interface Tracer {
    /**
     * Log the given data to the trace Log
     */
    log(message: string, verbose?: string): void;
  }

  /**
   * The change text document notification's parameters.
   */
  declare interface DidChangeTextDocumentParams {
    /**
     * The document that did change. The version number points
     * to the version after all provided content changes have
     * been applied.
     */
    textDocument: VersionedTextDocumentIdentifier;

    /**
     * The actual content changes.
     */
    contentChanges: TextDocumentContentChangeEvent[];
  }

  /**
   * The parameters send in a close text document notification
   */
  declare interface DidCloseTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: TextDocumentIdentifier;
  }

  /**
   * The parameters send in a open text document notification
   */
  declare interface DidOpenTextDocumentParams {
    /**
     * The document that was opened.
     */
    textDocument: TextDocumentItem;
  }

  /**
   * The publish diagnostic notification's parameters.
   */
  declare interface PublishDiagnosticsParams {
    /**
     * The URI for which diagnostic information is reported.
     */
    uri: string;

    /**
     * An array of diagnostic information items.
     */
    diagnostics: Diagnostic[];
  }

  /**
   * The parameters of a change configuration notification.
   */
  declare interface DidChangeConfigurationParams {
    /**
     * The actual changed settings
     */
    settings: any;
  }

  /**
   * The parameters send in a save text document notification
   */
  declare interface DidSaveTextDocumentParams {
    /**
     * The document that was closed.
     */
    textDocument: VersionedTextDocumentIdentifier;

    /**
     * Optional the content when saved. Depends on the includeText value
     * when the save notifcation was requested.
     */
    text?: string;
  }

  /**
   * The parameters send in a will save text document notification.
   */
  declare interface WillSaveTextDocumentParams {
    /**
     * The document that will be saved.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The 'TextDocumentSaveReason'.
     */
    reason: TextDocumentSaveReasonType;
  }

  /**
   * Interface to describe the shape of the server connection.
   */
  declare interface IConnection {
    /**
     * Start listening on the input stream for messages to process.
     */
    listen(): void;

    /**
     * Installs a request handler described by the given [RequestType](#RequestType).
     * @param type The [RequestType](#RequestType) describing the request.
     * @param handler The handler to install
     */
    onRequest<R, E, RO>(
      type: RequestType0<R, E, RO>,
      handler: RequestHandler0<R, E>,
    ): void;
    onRequest<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      handler: RequestHandler<P, R, E>,
    ): void;

    /**
     * Installs a request handler for the given method.
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onRequest<R, E>(method: string, handler: GenericRequestHandler<R, E>): void;

    /**
     * Send a request to the client.
     * @param type The [RequestType](#RequestType) describing the request.
     * @param params The request's parameters.
     */
    sendRequest<R, E, RO>(
      type: RequestType0<R, E, RO>,
      token?: CancellationToken,
    ): Promise<R>;
    sendRequest<P, R, E, RO>(
      type: RequestType<P, R, E, RO>,
      params: P,
      token?: CancellationToken,
    ): Promise<R>;

    /**
     * Send a request to the client.
     * @param method The method to invoke on the client.
     * @param params The request's parameters.
     */
    sendRequest<R>(method: string, ...params: any[]): Promise<R>;

    /**
     * Installs a notification handler described by the given [NotificationType](#NotificationType).
     * @param type The [NotificationType](#NotificationType) describing the notification.
     * @param handler The handler to install.
     */
    onNotification<RO>(
      type: NotificationType0<RO>,
      handler: NotificationHandler0,
    ): void;
    onNotification<P, RO>(
      type: NotificationType<P, RO>,
      handler: NotificationHandler<P>,
    ): void;

    /**
     * Installs a notification handler for the given method.
     * @param method The method to register a request handler for.
     * @param handler The handler to install.
     */
    onNotification(method: string, handler: GenericNotificationHandler): void;

    /**
     * Send a notification to the client.
     * @param type The [NotificationType](#NotificationType) describing the notification.
     * @param params The notification's parameters.
     */
    sendNotification<RO>(type: NotificationType0<RO>): void;
    sendNotification<P, RO>(type: NotificationType<P, RO>, params?: P): void;

    /**
     * Send a notification to the client.
     * @param method The method to invoke on the client.
     * @param params The notification's parameters.
     */
    sendNotification(method: string, ...args: any[]): void;

    /**
     * Installs a handler for the intialize request.
     * @param handler The initialize handler.
     */
    onInitialize(
      handler: RequestHandler<
        InitializeParams,
        InitializeResult,
        InitializeError,
      >,
    ): void;

    /**
     * Installs a handler for the intialized notification.
     * @param handler The initialized handler.
     */
    onInitialized(handler: NotificationHandler<InitializedParams>): void;

    /**
     * Installs a handler for the shutdown request.
     * @param handler The initialize handler.
     */
    onShutdown(handler: RequestHandler0<void, void>): void;

    /**
     * Installs a handler for the exit notification.
     * @param handler The exit handler.
     */
    onExit(handler: NotificationHandler0): void;

    /**
     * A proxy interface for the language client interface to register for requests or
     * notifications.
     */
    client: RemoteClient;

    /**
     * A proxy for VSCode's development console. See [RemoteConsole](#RemoteConsole)
     */
    console: RemoteConsole;

    /**
     * A proxy for VSCode's window. See [RemoteWindow](#RemoteWindow)
     */
    window: RemoteWindow;

    /**
     * A proxy to send telemetry events to the client.
     */
    telemetry: Telemetry;

    /**
     * A proxy to send trace events to the client.
     */
    tracer: Tracer;

    /**
     * A proxy to talk to the client's workspace.
     */
    workspace: RemoteWorkspace;

    /**
     * Installs a handler for the `DidChangeConfiguration` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeConfiguration(
      handler: NotificationHandler<DidChangeConfigurationParams>,
    ): void;

    /**
     * Installs a handler for the `DidChangeWatchedFiles` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeWatchedFiles(
      handler: NotificationHandler<DidChangeWatchedFilesParams>,
    ): void;

    /**
     * Installs a handler for the `DidOpenTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidOpenTextDocument(
      handler: NotificationHandler<DidOpenTextDocumentParams>,
    ): void;

    /**
     * Installs a handler for the `DidChangeTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidChangeTextDocument(
      handler: NotificationHandler<DidChangeTextDocumentParams>,
    ): void;

    /**
     * Installs a handler for the `DidCloseTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidCloseTextDocument(
      handler: NotificationHandler<DidCloseTextDocumentParams>,
    ): void;

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocument(
      handler: NotificationHandler<WillSaveTextDocumentParams>,
    ): void;

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onWillSaveTextDocumentWaitUntil(
      handler: RequestHandler<WillSaveTextDocumentParams, TextEdit[], void>,
    ): void;

    /**
     * Installs a handler for the `DidSaveTextDocument` notification.
     * @param handler The corresponding handler.
     */
    onDidSaveTextDocument(
      handler: NotificationHandler<DidSaveTextDocumentParams>,
    ): void;

    /**
     * Sends diagnostics computed for a given document to VSCode to render them in the
     * user interface.
     * @param params The diagnostic parameters.
     */
    sendDiagnostics(params: PublishDiagnosticsParams): void;

    /**
     * Installs a handler for the `Hover` request.
     * @param handler The corresponding handler.
     */
    onHover(
      handler: RequestHandler<TextDocumentPositionParams, Hover, void>,
    ): void;

    /**
     * Installs a handler for the `Completion` request.
     * @param handler The corresponding handler.
     */
    onCompletion(
      handler: RequestHandler<
        TextDocumentPositionParams,
        CompletionItem[] | CompletionList,
        void,
      >,
    ): void;

    /**
     * Installs a handler for the `CompletionResolve` request.
     * @param handler The corresponding handler.
     */
    onCompletionResolve(
      handler: RequestHandler<CompletionItem, CompletionItem, void>,
    ): void;

    /**
     * Installs a handler for the `SignatureHelp` request.
     * @param handler The corresponding handler.
     */
    onSignatureHelp(
      handler: RequestHandler<TextDocumentPositionParams, SignatureHelp, void>,
    ): void;

    /**
     * Installs a handler for the `Definition` request.
     * @param handler The corresponding handler.
     */
    onDefinition(
      handler: RequestHandler<TextDocumentPositionParams, Definition, void>,
    ): void;

    /**
     * Installs a handler for the `References` request.
     * @param handler The corresponding handler.
     */
    onReferences(
      handler: RequestHandler<ReferenceParams, Location[], void>,
    ): void;

    /**
     * Installs a handler for the `DocumentHighlight` request.
     * @param handler The corresponding handler.
     */
    onDocumentHighlight(
      handler: RequestHandler<
        TextDocumentPositionParams,
        DocumentHighlight[],
        void,
      >,
    ): void;

    /**
     * Installs a handler for the `DocumentSymbol` request.
     * @param handler The corresponding handler.
     */
    onDocumentSymbol(
      handler: RequestHandler<DocumentSymbolParams, SymbolInformation[], void>,
    ): void;

    /**
     * Installs a handler for the `WorkspaceSymbol` request.
     * @param handler The corresponding handler.
     */
    onWorkspaceSymbol(
      handler: RequestHandler<WorkspaceSymbolParams, SymbolInformation[], void>,
    ): void;

    /**
     * Installs a handler for the `CodeAction` request.
     * @param handler The corresponding handler.
     */
    onCodeAction(
      handler: RequestHandler<CodeActionParams, Command[], void>,
    ): void;

    /**
     * Compute a list of [lenses](#CodeLens). This call should return as fast as possible and if
     * computing the commands is expensive implementors should only return code lens objects with the
     * range set and handle the resolve request.
     * @param handler The corresponding handler.
     */
    onCodeLens(handler: RequestHandler<CodeLensParams, CodeLens[], void>): void;

    /**
     * This function will be called for each visible code lens, usually when scrolling and after
     * the onCodeLens has been called.
     * @param handler The corresponding handler.
     */
    onCodeLensResolve(handler: RequestHandler<CodeLens, CodeLens, void>): void;

    /**
     * Installs a handler for the document formatting request.
     * @param handler The corresponding handler.
     */
    onDocumentFormatting(
      handler: RequestHandler<DocumentFormattingParams, TextEdit[], void>,
    ): void;

    /**
     * Installs a handler for the document range formatting request.
     * @param handler The corresponding handler.
     */
    onDocumentRangeFormatting(
      handler: RequestHandler<DocumentRangeFormattingParams, TextEdit[], void>,
    ): void;

    /**
     * Installs a handler for the document on type formatting request.
     * @param handler The corresponding handler.
     */
    onDocumentOnTypeFormatting(
      handler: RequestHandler<DocumentOnTypeFormattingParams, TextEdit[], void>,
    ): void;

    /**
     * Installs a handler for the rename request.
     * @param handler The corresponding handler.
     */
    onRenameRequest(
      handler: RequestHandler<RenameParams, WorkspaceEdit, void>,
    ): void;

    /**
     * Installs a handler for the document links request.
     * @param handler The corresponding handler.
     */
    onDocumentLinks(
      handler: RequestHandler<DocumentLinkParams, DocumentLink[], void>,
    ): void;

    /**
     * Installs a handler for the document links resolve request.
     * @param handler The corresponding handler.
     */
    onDocumentLinkResolve(
      handler: RequestHandler<DocumentLink, DocumentLink, void>,
    ): void;

    /**
     * Installs a handler for the execute command request.
     * @param handler The corresponding handler.
     */
    onExecuteCommand(
      handler: RequestHandler<ExecuteCommandParams, any, void>,
    ): void;

    /**
     * Disposes the connection
     */
    dispose(): void;
  }
  /**
   * Creates a new connection using a the given streams.
   * @param inputStream The stream to read messages from.
   * @param outputStream The stream to write messages to.
   * @return  a [connection](#IConnection)
   */
  declare function createConnection(
    inputStream: stream$Readable,
    outputStream: stream$Writable,
  ): IConnection;

  declare function createConnection(): IConnection;

  declare class IPCMessageReader extends stream$Readable {}

  declare class IPCMessageWriter extends stream$Writable {}
}

declare module 'vscode-languageserver/lib/protocol' {
  import type {
    DidOpenTextDocumentParams,
    DidChangeTextDocumentParams,
    DidCloseTextDocumentParams,
    DidSaveTextDocumentParams,
    WillSaveTextDocumentParams,
    DidChangeConfigurationParams,
    TextDocumentSyncKindType,
    PublishDiagnosticsParams,
  } from 'vscode-languageserver';

  import type {
    ICodeActionContext,
    IFormattingOptions,
    ReferenceContext,
  } from 'vscode-languageserver-types';

  /**
   * A document filter denotes a document by different properties like
   * the [language](#TextDocument.languageId), the [scheme](#Uri.scheme) of
   * its resource, or a glob-pattern that is applied to the [path](#TextDocument.fileName).
   * @sample  A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
   * @sample  A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**package.json' }`
   */
  declare type DocumentFilter =
    | {
        /**
         * A language id, like `typescript`.
         */
        language: string,

        /**
         * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
         */
        scheme?: string,

        /**
         * A glob pattern, like `.{ts,js}`.
         */
        pattern?: string,
      }
    | {
        /**
         * A language id, like `typescript`.
         */
        language?: string,

        /**
         * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
         */
        scheme: string,

        /**
         * A glob pattern, like `.{ts,js}`.
         */
        pattern?: string,
      }
    | {
        /**
         * A language id, like `typescript`.
         */
        language?: string,

        /**
         * A Uri [scheme](#Uri.scheme), like `file` or `untitled`.
         */
        scheme?: string,

        /**
         * A glob pattern, like `.{ts,js}`.
         */
        pattern: string,
      };
  declare function DocumentFilter$is(value: any): DocumentFilter;
  declare var vscodeLanguageserver$DocumentFilter: {
    is: typeof DocumentFilter$is,
  };
  /**
   * A document selector is the combination of one or many document filters.
   * @sample  `let sel:DocumentSelector = [{ language: 'typescript' }, { language: 'json', pattern: '**âˆ•tsconfig.json' }]`;
   */
  declare type DocumentSelector = (string | DocumentFilter)[];
  /**
   * General paramters to to regsiter for an notification or to register a provider.
   */
  declare interface Registration {
    /**
     * The id used to register the request. The id can be used to deregister
     * the request again.
     */
    id: string;

    /**
     * The method to register for.
     */
    method: string;

    /**
     * Options necessary for the registration.
     */
    registerOptions?: any;
  }
  declare interface RegistrationParams {
    registrations: Registration[];
  }
  declare var type: RequestType<RegistrationParams, void, void, void>;
  /**
   * General parameters to unregister a request or notification.
   */
  declare interface Unregistration {
    /**
     * The id used to unregister the request or notification. Usually an id
     * provided during the register request.
     */
    id: string;

    /**
     * The method to unregister for.
     */
    method: string;
  }
  declare interface UnregistrationParams {
    unregisterations: Unregistration[];
  }
  declare var type: RequestType<UnregistrationParams, void, void, void>;
  /**
   * A parameter literal used in requests to pass a text document and a position inside that
   * document.
   */
  declare interface TextDocumentPositionParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The position inside the text document.
     */
    position: Position;
  }
  /**
   * Workspace specific client capabilities.
   */
  declare interface WorkspaceClientCapabilites {
    /**
     * The client supports applying batch edits
     * to the workspace by supporting the request
     * 'workspace/applyEdit'
     */
    applyEdit?: boolean;

    /**
     * Capabilities specific to `WorkspaceEdit`s
     */
    workspaceEdit?: {
      /**
       * The client supports versioned document changes in `WorkspaceEdit`s
       */
      documentChanges?: boolean,
    };

    /**
     * Capabilities specific to the `workspace/didChangeConfiguration` notification.
     */
    didChangeConfiguration?: {
      /**
       * Did change configuration notification supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `workspace/didChangeWatchedFiles` notification.
     */
    didChangeWatchedFiles?: {
      /**
       * Did change watched files notification supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `workspace/symbol` request.
     */
    symbol?: {
      /**
       * Symbol request supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `workspace/executeCommand` request.
     */
    executeCommand?: {
      /**
       * Execute command supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };
  }
  /**
   * Text document specific client capabilities.
   */
  declare interface TextDocumentClientCapabilities {
    /**
     * Defines which synchronization capabilities the client supports.
     */
    synchronization?: {
      /**
       * Whether text document synchronization supports dynamic registration.
       */
      dynamicRegistration?: boolean,

      /**
       * The client supports sending will save notifications.
       */
      willSave?: boolean,

      /**
       * The client supports sending a will save request and
       * waits for a response providing text edits which will
       * be applied to the document before it is saved.
       */
      willSaveWaitUntil?: boolean,

      /**
       * The client supports did save notifications.
       */
      didSave?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/completion`
     */
    completion?: {
      /**
       * Whether completion supports dynamic registration.
       */
      dynamicRegistration?: boolean,

      /**
       * The client supports the following `CompletionItem` specific
       * capabilities.
       */
      completionItem?: {
        /**
         * Client supports snippets as insert text.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         */
        snippetSupport?: boolean,
      },
    };

    /**
     * Capabilities specific to the `textDocument/hover`
     */
    hover?: {
      /**
       * Whether hover supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/signatureHelp`
     */
    signatureHelp?: {
      /**
       * Whether signature help supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/references`
     */
    references?: {
      /**
       * Whether references supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/documentHighlight`
     */
    documentHighlight?: {
      /**
       * Whether document highlight supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/documentSymbol`
     */
    documentSymbol?: {
      /**
       * Whether document symbol supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/formatting`
     */
    formatting?: {
      /**
       * Whether formatting supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/rangeFormatting`
     */
    rangeFormatting?: {
      /**
       * Whether range formatting supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/onTypeFormatting`
     */
    onTypeFormatting?: {
      /**
       * Whether on type formatting supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/definition`
     */
    definition?: {
      /**
       * Whether definition supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/codeAction`
     */
    codeAction?: {
      /**
       * Whether code action supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/codeLens`
     */
    codeLens?: {
      /**
       * Whether code lens supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/documentLink`
     */
    documentLink?: {
      /**
       * Whether document link supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };

    /**
     * Capabilities specific to the `textDocument/rename`
     */
    rename?: {
      /**
       * Whether rename supports dynamic registration.
       */
      dynamicRegistration?: boolean,
    };
  }
  /**
   * Defines the capabilities provided by the client.
   */
  declare interface ClientCapabilities {
    /**
     * Workspace specific client capabilities.
     */
    workspace?: WorkspaceClientCapabilites;

    /**
     * Text document specific client capabilities.
     */
    textDocument?: TextDocumentClientCapabilities;

    /**
     * Experimental client capabilities.
     */
    experimental?: any;
  }

  /**
   * General text document registration options.
   */
  declare interface TextDocumentRegistrationOptions {
    /**
     * A document selector to identify the scope of the registration. If set to null
     * the document selector provided on the client side will be used.
     */
    documentSelector: DocumentSelector | null;
  }
  /**
   * Completion options.
   */
  declare interface CompletionOptions {
    /**
     * The server provides support to resolve additional
     * information for a completion item.
     */
    resolveProvider?: boolean;

    /**
     * The characters that trigger completion automatically.
     */
    triggerCharacters?: string[];
  }
  /**
   * Signature help options.
   */
  declare interface SignatureHelpOptions {
    /**
     * The characters that trigger signature help
     * automatically.
     */
    triggerCharacters?: string[];
  }
  /**
   * Code Lens options.
   */
  declare interface CodeLensOptions {
    /**
     * Code lens has a resolve provider as well.
     */
    resolveProvider?: boolean;
  }
  /**
   * Format document on type options
   */
  declare interface DocumentOnTypeFormattingOptions {
    /**
     * A character on which formatting should be triggered, like `}`.
     */
    firstTriggerCharacter: string;

    /**
     * More trigger characters.
     */
    moreTriggerCharacter?: string[];
  }
  /**
   * Document link options
   */
  declare interface DocumentLinkOptions {
    /**
     * Document links have a resolve provider as well.
     */
    resolveProvider?: boolean;
  }
  /**
   * Execute command options.
   */
  declare interface ExecuteCommandOptions {
    /**
     * The commands to be executed on the server
     */
    commands: string[];
  }
  /**
   * Save options.
   */
  declare interface SaveOptions {
    /**
     * The client is supposed to include the content on save.
     */
    includeText?: boolean;
  }
  declare interface TextDocumentSyncOptions {
    /**
     * Open and close notifications are sent to the server.
     */
    openClose?: boolean;

    /**
     * Change notificatins are sent to the server. See TextDocumentSyncKind.None, TextDocumentSyncKind.Full
     * and TextDocumentSyncKindIncremental.
     */
    change?: TextDocumentSyncKindType;

    /**
     * Will save notifications are sent to the server.
     */
    willSave?: boolean;

    /**
     * Will save wait until requests are sent to the server.
     */
    willSaveWaitUntil?: boolean;

    /**
     * Save notifications are sent to the server.
     */
    save?: SaveOptions;
  }
  /**
   * Defines the capabilities provided by a language
   * server.
   */
  declare interface ServerCapabilities {
    /**
     * Defines how text documents are synced. Is either a detailed structure defining each notification or
     * for backwards compatibility the TextDocumentSyncKind number.
     */
    textDocumentSync?: TextDocumentSyncOptions | TextDocumentSyncKindType;

    /**
     * The server provides hover support.
     */
    hoverProvider?: boolean;

    /**
     * The server provides completion support.
     */
    completionProvider?: CompletionOptions;

    /**
     * The server provides signature help support.
     */
    signatureHelpProvider?: SignatureHelpOptions;

    /**
     * The server provides goto definition support.
     */
    definitionProvider?: boolean;

    /**
     * The server provides find references support.
     */
    referencesProvider?: boolean;

    /**
     * The server provides document highlight support.
     */
    documentHighlightProvider?: boolean;

    /**
     * The server provides document symbol support.
     */
    documentSymbolProvider?: boolean;

    /**
     * The server provides workspace symbol support.
     */
    workspaceSymbolProvider?: boolean;

    /**
     * The server provides code actions.
     */
    codeActionProvider?: boolean;

    /**
     * The server provides code lens.
     */
    codeLensProvider?: CodeLensOptions;

    /**
     * The server provides document formatting.
     */
    documentFormattingProvider?: boolean;

    /**
     * The server provides document range formatting.
     */
    documentRangeFormattingProvider?: boolean;

    /**
     * The server provides document formatting on typing.
     */
    documentOnTypeFormattingProvider?: {
      /**
       * A character on which formatting should be triggered, like `}`.
       */
      firstTriggerCharacter: string,

      /**
       * More trigger characters.
       */
      moreTriggerCharacter?: string[],
    };

    /**
     * The server provides rename support.
     */
    renameProvider?: boolean;

    /**
     * The server provides document link support.
     */
    documentLinkProvider?: DocumentLinkOptions;

    /**
     * The server provides execute command support.
     */
    executeCommandProvider?: ExecuteCommandOptions;

    /**
     * Experimental server capabilities.
     */
    experimental?: any;
  }

  declare var type: RequestType<
    InitializeParams,
    InitializeResult,
    InitializeError,
    void,
  >;

  /**
   * The initialize parameters
   */
  declare interface InitializeParams {
    /**
     * The process Id of the parent process that started
     * the server.
     */
    processId: number;

    /**
     * The rootPath of the workspace. Is null
     * if no folder is open.
     * @deprecated  in favour of rootUri.
     */
    rootPath?: string | null;

    /**
     * The rootUri of the workspace. Is null if no
     * folder is open. If both `rootPath` and `rootUri` are set
     * `rootUri` wins.
     */
    rootUri: string | null;

    /**
     * The capabilities provided by the client (editor or tool)
     */
    capabilities: ClientCapabilities;

    /**
     * User provided initialization options.
     */
    initializationOptions?: any;

    /**
     * The initial trace setting. If omitted trace is disabled ('off').
     */
    trace?: 'off' | 'messages' | 'verbose';
  }

  /**
   * The result returned from an initilize request.
   */
  declare interface InitializeResult {
    /**
     * The capabilities the language server provides.
     */
    capabilities: ServerCapabilities;
  }

  declare var unknownProtocolVersion: number;

  /**
   * The data type of the ResponseError if the
   * initialize request fails.
   */
  declare interface InitializeError {
    /**
       * Indicates whether the client should retry to send the
       * initialize request after showing the message provided
      in the {@link ResponseError}
      */
    retry: boolean;
  }

  declare interface InitializedParams {}
  declare var type: NotificationType<InitializedParams, void>;
  declare var type: RequestType0<void, void, void>;
  declare var type: NotificationType0<void>;
  declare var type: NotificationType<DidChangeConfigurationParams, void>;

  declare var MessageType: {
    Error: 1,
    Warning: 2,
    Info: 3,
    Log: 4,
  };
  declare type MessageTypeType = 1 | 2 | 3 | 4;

  /**
   * The parameters of a notification message.
   */
  declare interface ShowMessageParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: MessageTypeType;

    /**
     * The actual message
     */
    message: string;
  }
  declare var type: NotificationType<ShowMessageParams, void>;

  declare interface MessageActionItem {
    /**
     * A short title like 'Retry', 'Open Log' etc.
     */
    title: string;
  }

  declare interface ShowMessageRequestParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: MessageTypeType;

    /**
     * The actual message
     */
    message: string;

    /**
     * The message action items to present.
     */
    actions?: MessageActionItem[];
  }

  /**
   * The log message parameters.
   */
  declare interface LogMessageParams {
    /**
     * The message type. See {@link MessageType}
     */
    type: MessageTypeType;

    /**
     * The actual message
     */
    message: string;
  }

  declare var type: RequestType<
    ShowMessageRequestParams,
    MessageActionItem,
    void,
    void,
  >;

  declare var type: NotificationType<LogMessageParams, void>;
  declare var type: NotificationType<any, void>;
  declare var type: NotificationType<
    DidOpenTextDocumentParams,
    TextDocumentRegistrationOptions,
  >;

  /**
   * Descibe options to be used when registered for text document change events.
   */
  declare type TextDocumentChangeRegistrationOptions = {
    /**
     * How documents are synced to the server.
     */
    syncKind: TextDocumentSyncKindType,
  } & TextDocumentRegistrationOptions;

  declare var type: NotificationType<
    DidChangeTextDocumentParams,
    TextDocumentChangeRegistrationOptions,
  >;

  declare var type: NotificationType<
    DidCloseTextDocumentParams,
    TextDocumentRegistrationOptions,
  >;

  /**
   * Save registration options.
   */
  declare type TextDocumentSaveRegistrationOptions = {} & TextDocumentRegistrationOptions &
    SaveOptions;

  declare var type: NotificationType<
    DidSaveTextDocumentParams,
    TextDocumentSaveRegistrationOptions,
  >;

  declare var type: NotificationType<
    WillSaveTextDocumentParams,
    TextDocumentRegistrationOptions,
  >;

  declare var type: RequestType<
    WillSaveTextDocumentParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare var type: NotificationType<DidChangeWatchedFilesParams, void>;

  /**
   * The watched files change notification's parameters.
   */
  declare interface DidChangeWatchedFilesParams {
    /**
     * The actual file events.
     */
    changes: FileEvent[];
  }

  declare var FileChangeType: {
    Created: 1,
    Changed: 2,
    Deleted: 3,
  };
  declare type FileChangeTypeType = 1 | 2 | 3;

  /**
   * An event describing a file change.
   */
  declare interface FileEvent {
    /**
     * The file's uri.
     */
    uri: string;

    /**
     * The change type.
     */
    type: FileChangeTypeType;
  }

  declare var type: NotificationType<PublishDiagnosticsParams, void>;

  /**
   * Completion registration options.
   */
  declare type CompletionRegistrationOptions = {} & TextDocumentRegistrationOptions &
    CompletionOptions;

  declare var type: RequestType<
    TextDocumentPositionParams,
    CompletionList | CompletionItem[],
    void,
    CompletionRegistrationOptions,
  >;

  declare var type: RequestType<CompletionItem, CompletionItem, void, void>;

  declare var type: RequestType<
    TextDocumentPositionParams,
    Hover,
    void,
    TextDocumentRegistrationOptions,
  >;

  /**
   * Signature help registration options.
   */
  declare type SignatureHelpRegistrationOptions = {} & TextDocumentRegistrationOptions &
    SignatureHelpOptions;

  declare var type: RequestType<
    TextDocumentPositionParams,
    SignatureHelp,
    void,
    SignatureHelpRegistrationOptions,
  >;

  declare var type: RequestType<
    TextDocumentPositionParams,
    Definition,
    void,
    TextDocumentRegistrationOptions,
  >;

  /**
   * Parameters for a [ReferencesRequest](#ReferencesRequest).
   */
  declare type ReferenceParams = {
    context: ReferenceContext,
  } & TextDocumentPositionParams;

  declare var type: RequestType<
    ReferenceParams,
    Location[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare var type: RequestType<
    TextDocumentPositionParams,
    DocumentHighlight[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare var type: RequestType<
    DocumentSymbolParams,
    SymbolInformation[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare var type: RequestType<
    WorkspaceSymbolParams,
    SymbolInformation[],
    void,
    void,
  >;

  /**
   * Params for the CodeActionRequest
   */
  declare interface CodeActionParams {
    /**
     * The document in which the command was invoked.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The range for which the command was invoked.
     */
    range: Range;

    /**
     * Context carrying additional information.
     */
    context: ICodeActionContext;
  }

  declare var type: RequestType<
    CodeActionParams,
    Command[],
    void,
    TextDocumentRegistrationOptions,
  >;

  /**
   * Params for the Code Lens request.
   */
  declare interface CodeLensParams {
    /**
     * The document to request code lens for.
     */
    textDocument: TextDocumentIdentifier;
  }

  /**
   * Code Lens registration options.
   */
  declare type CodeLensRegistrationOptions = {} & TextDocumentRegistrationOptions &
    CodeLensOptions;

  declare var type: RequestType<
    CodeLensParams,
    CodeLens[],
    void,
    CodeLensRegistrationOptions,
  >;

  declare var type: RequestType<CodeLens, CodeLens, void, void>;

  declare interface DocumentFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The format options
     */
    options: IFormattingOptions;
  }

  declare var type: RequestType<
    DocumentFormattingParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare interface DocumentRangeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The range to format
     */
    range: Range;

    /**
     * The format options
     */
    options: IFormattingOptions;
  }

  declare var type: RequestType<
    DocumentRangeFormattingParams,
    TextEdit[],
    void,
    TextDocumentRegistrationOptions,
  >;

  declare interface DocumentOnTypeFormattingParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The position at which this request was send.
     */
    position: Position;

    /**
     * The character that has been typed.
     */
    ch: string;

    /**
     * The format options.
     */
    options: IFormattingOptions;
  }

  /**
   * Format document on type options
   */
  declare type DocumentOnTypeFormattingRegistrationOptions = {} & TextDocumentRegistrationOptions &
    DocumentOnTypeFormattingOptions;

  declare var type: RequestType<
    DocumentOnTypeFormattingParams,
    TextEdit[],
    void,
    DocumentOnTypeFormattingRegistrationOptions,
  >;

  declare interface RenameParams {
    /**
     * The document to format.
     */
    textDocument: TextDocumentIdentifier;

    /**
     * The position at which this request was send.
     */
    position: Position;

    /**
     * The new name of the symbol. If the given name is not valid the
     * request must return a [ResponseError](#ResponseError) with an
     * appropriate message set.
     */
    newName: string;
  }

  declare var type: RequestType<
    RenameParams,
    WorkspaceEdit,
    void,
    TextDocumentRegistrationOptions,
  >;

  declare interface DocumentLinkParams {
    /**
     * The document to provide document links for.
     */
    textDocument: TextDocumentIdentifier;
  }

  /**
   * Document link registration options
   */
  declare type DocumentLinkRegistrationOptions = {} & TextDocumentRegistrationOptions &
    DocumentLinkOptions;

  declare var type: RequestType<
    DocumentLinkParams,
    DocumentLink[],
    void,
    DocumentLinkRegistrationOptions,
  >;

  declare var type: RequestType<DocumentLink, DocumentLink, void, void>;

  declare interface ExecuteCommandParams {
    /**
     * The identifier of the actual command handler.
     */
    command: string;

    /**
     * Arguments that the command should be invoked with.
     */
    arguments?: any[];
  }

  /**
   * Execute command registration options.
   */
  declare type ExecuteCommandRegistrationOptions = {} & ExecuteCommandOptions;

  declare var type: RequestType<
    ExecuteCommandParams,
    any,
    void,
    ExecuteCommandRegistrationOptions,
  >;

  /**
   * The parameters passed via a apply workspace edit request.
   */
  declare interface ApplyWorkspaceEditParams {
    /**
     * The edits to apply.
     */
    edit: WorkspaceEdit;
  }

  /**
   * A reponse returned from the apply workspace edit request.
   */
  declare interface ApplyWorkspaceEditResponse {
    /**
     * Indicates whether the edit was applied or not.
     */
    applied: boolean;
  }

  declare var type: RequestType<
    ApplyWorkspaceEditParams,
    ApplyWorkspaceEditResponse,
    void,
    void,
  >;
}
