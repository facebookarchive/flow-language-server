/**
 * Flowtype definitions for vscode-languageserver
 * Originally Generated by Flowgen from a Typescript Definition
 */

declare module 'vscode-languageserver-types' {
  /**
   * Position in a text document expressed as zero-based line and character offset.
   */
  declare interface IPosition {
    /**
     * Line position in a document (zero-based).
     */
    line: number;

    /**
     * Character offset on a line in a document (zero-based). Assuming that the line is
     * represented as a string, the `character` value represents the gap between the
     * `character` and `character + 1`. Given the following line: 'aêêÄc', character 0 is
     * the gap between the start of the start and 'a' ('|aêêÄc'), character 1 is the gap
     * between 'a' and 'êêÄ' ('a|êêÄc') and character 2 is the gap between 'êêÄ' and 'b' ('aêêÄ|c').
     *
     * The string 'aêêÄc' consist of 3 characters with valid character values being 0, 1, 2, 3
     * for that string. Note that the string encoded in UTF-16 is encoded using 4 code units
     * (the êêÄ is encoded using two code units). The character offset is therefore encoding
     * independent.
     */
    character: number;
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Position$create(line: number, character: number): IPosition;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Position$is(value: any): IPosition;

  declare var Position: {
    create: typeof Position$create,
    is: typeof Position$is,
  };

  /**
   * A range in a text document expressed as (zero-based) start and end positions.
   */
  declare export interface IRange {
    /**
     * The range's start position
     */
    start: IPosition;

    /**
     * The range's end position
     */
    end: IPosition;
  }

  declare var Range: {
    /**
     * Create a new Range liternal.
     * @param start The range's start position.
     * @param end The range's end position.
     */
    create(start: IPosition, end: IPosition): IRange,
    create(
      startLine: number,
      startCharacter: number,
      endLine: number,
      endCharacter: number,
    ): IRange,
    create(
      one: Position | number,
      two: Position | number,
      three?: number,
      four?: number,
    ): IRange,

    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    is(value: any): boolean,
  };

  /**
   * Represents a location inside a resource, such as a line
   * inside a text file.
   */
  declare interface ILocation {
    uri: string;
    range: IRange;
  }

  /**
   * Creates a Location literal.
   * @param uri The location's uri.
   * @param range The location's range.
   */
  declare function Location$create(uri: string, range: IRange): ILocation;

  /**
   * Checks whether the given literal conforms to the [Location](#Location) interface.
   */
  declare function Location$is(value: any): boolean;

  declare var Location: {
    create: typeof Location$create,
    is: typeof Location$is,
  };

  declare var DiagnosticSeverity: {
    Error: 1,
    Warning: 2,
    Information: 3,
    Hint: 4,
  };

  declare type DiagnosticSeverityType = 1 | 2 | 3 | 4;

  /**
   * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
   * are only valid in the scope of a resource.
   */
  declare interface IDiagnostic {
    /**
     * The range at which the message applies
     */
    range: IRange;

    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverityType;

    /**
     * The diagnostic's code. Can be omitted.
     */
    code?: number | string;

    /**
     * A human-readable string describing the source of this
     * diagnostic, e.g. 'typescript' or 'super lint'.
     */
    source?: string;

    /**
     * The diagnostic's message.
     */
    message: string;
  }

  /**
   * Creates a new Diagnostic literal.
   */
  declare function Diagnostic$create(
    range: IRange,
    message: string,
    severity?: DiagnosticSeverityType,
    code?: number | string,
    source?: string,
  ): IDiagnostic;

  /**
   * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
   */
  declare function Diagnostic$is(value: any): boolean;

  declare var Diagnostic: {
    create: typeof Diagnostic$create,
    is: typeof Diagnostic$is,
  };

  /**
   * Represents a reference to a command. Provides a title which
   * will be used to represent a command in the UI and, optionally,
   * an array of arguments which will be passed to the command handler
   * function when invoked.
   */
  declare interface ICommand {
    /**
     * Title of the command, like `save`.
     */
    title: string;

    /**
     * The identifier of the actual command handler.
     */
    command: string;

    /**
     * Arguments that the command handler should be
     * invoked with.
     */
    arguments?: any[];
  }

  /**
   * Creates a new Command literal.
   */
  declare function Command$create(
    title: string,
    command: string,
    ...args: Array<any>
  ): ICommand;

  /**
   * Checks whether the given literal conforms to the [Command](#Command) interface.
   */
  declare function Command$is(value: any): boolean;

  declare var Command: {
    create: typeof Command$create,
    is: typeof Command$is,
  };

  /**
   * A text edit applicable to a text document.
   */
  declare interface ITextEdit {
    /**
     * The range of the text document to be manipulated. To insert
     * text into a document create a range where start === end.
     */
    range: IRange;

    /**
     * The string to be inserted. For delete operations use an
     * empty string.
     */
    newText: string;
  }

  /**
   * Creates a replace text edit.
   * @param range The range of text to be replaced.
   * @param newText The new text.
   */
  declare function TextEdit$replace(range: IRange, newText: string): ITextEdit;

  /**
   * Creates a insert text edit.
   * @param psotion The position to insert the text at.
   * @param newText The text to be inserted.
   */
  declare function TextEdit$insert(
    position: IPosition,
    newText: string,
  ): ITextEdit;

  /**
   * Creates a delete text edit.
   * @param range The range of text to be deleted.
   */
  declare function TextEdit$del(range: IRange): ITextEdit;

  declare var TextEdit: {
    replace: typeof TextEdit$replace,
    insert: typeof TextEdit$insert,
    del: typeof TextEdit$del,
  };

  /**
   * An identifier to denote a specific version of a text document.
   */
  declare type IVersionedTextDocumentIdentifier = {
    /**
     * The version number of this document.
     */
    version: number,
  } & ITextDocumentIdentifier;

  /**
   * Creates a new VersionedTextDocumentIdentifier literal.
   * @param uri The document's uri.
   * @param uri The document's text.
   */
  declare function VersionedTextDocumentIdentifier$create(
    uri: string,
    version: number,
  ): IVersionedTextDocumentIdentifier;

  /**
   * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
   */
  declare function VersionedTextDocumentIdentifier$is(value: any): boolean;

  declare var VersionedTextDocumentIdentifier: {
    create: typeof VersionedTextDocumentIdentifier$create,
    is: typeof VersionedTextDocumentIdentifier$is,
  };

  /**
   * Describes textual changes on a text document.
   */
  declare interface ITextDocumentEdit {
    /**
     * The text document to change.
     */
    textDocument: IVersionedTextDocumentIdentifier;

    /**
     * The edits to be applied.
     */
    edits: Array<ITextEdit>;
  }

  /**
   * Creates a new `TextDocumentEdit`
   */
  declare function TextDocumentEdit$create(
    textDocument: IVersionedTextDocumentIdentifier,
    edits: Array<ITextEdit>,
  ): ITextDocumentEdit;

  declare function TextDocumentEdit$is(value: any): boolean;

  declare var TextDocumentEdit: {
    create: typeof TextDocumentEdit$create,
    is: typeof TextDocumentEdit$is,
  };

  /**
   * A workspace edit represents changes to many resources managed in the workspace. The edit
   * should either provide `changes` or `documentChanges`. If documentChanges are present
   * they are preferred over `changes` if the client can handle versioned document edits.
   */
  declare interface WorkspaceEdit {
    /**
     * Holds changes to existing resources.
     */
    changes?: {
      [uri: string]: Array<ITextEdit>,
    };

    /**
     * An array of `TextDocumentEdit`s to express changes to specific a specific
     * version of a text document. Whether a client supports versioned document
     * edits is expressed via `WorkspaceClientCapabilites.versionedWorkspaceEdit`.
     */
    documentChanges?: Array<ITextDocumentEdit>;
  }

  /**
   * A change to capture text edits for existing resources.
   */
  declare interface TextEditChange {
    /**
     * Gets all text edits for this change.
     * @return  An array of text edits.
     */
    all(): Array<TextEdit>;

    /**
     * Clears the edits for this change.
     */
    clear(): void;

    /**
     * Adds a text edit.
     * @param edit the text edit to add.
     */
    add(edit: TextEdit): void;

    /**
     * Insert the given text at the given position.
     * @param position A position.
     * @param newText A string.
     */
    insert(position: IPosition, newText: string): void;

    /**
     * Replace the given range with given text for the given resource.
     * @param range A range.
     * @param newText A string.
     */
    replace(range: IRange, newText: string): void;

    /**
     * Delete the text at the given range.
     * @param range A range.
     */
    delete(range: IRange): void;
  }

  /**
   * A workspace change helps constructing changes to a workspace.
   */
  declare class WorkspaceChange {
    constructor(workspaceEdit?: WorkspaceEdit): this;

    /**
     * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
     * use to be returned from a workspace edit operation like rename.
     */
    edit: WorkspaceEdit;

    /**
     * Returns the [TextEditChange](#TextEditChange) to manage text edits
     * for resources.
     */
    getTextEditChange(
      textDocument: IVersionedTextDocumentIdentifier,
    ): TextEditChange;
    getTextEditChange(uri: string): TextEditChange;
  }

  /**
   * A literal to identify a text document in the client.
   */
  declare interface ITextDocumentIdentifier {
    /**
     * The text document's uri.
     */
    uri: string;
  }

  /**
   * Creates a new TextDocumentIdentifier literal.
   * @param uri The document's uri.
   */
  declare function TextDocumentIdentifier$create(
    uri: string,
  ): ITextDocumentIdentifier;

  /**
   * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
   */
  declare function TextDocumentIdentifier$is(value: any): boolean;

  declare var TextDocumentIdentifier: {
    create: typeof TextDocumentIdentifier$create,
    is: typeof TextDocumentIdentifier$is,
  };

  /**
   * An item to transfer a text document from the client to the
   * server.
   */
  declare interface ITextDocumentItem {
    /**
     * The text document's uri.
     */
    uri: string;

    /**
     * The text document's language identifier
     */
    languageId: string;

    /**
     * The version number of this document (it will strictly increase after each
     * change, including undo/redo).
     */
    version: number;

    /**
     * The content of the opened text document.
     */
    text: string;
  }

  /**
   * Creates a new TextDocumentItem literal.
   * @param uri The document's uri.
   * @param uri The document's language identifier.
   * @param uri The document's version number.
   * @param uri The document's text.
   */
  declare function TextDocumentItem$create(
    uri: string,
    languageId: string,
    version: number,
    text: string,
  ): ITextDocumentItem;

  /**
   * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
   */
  declare function TextDocumentItem$is(value: any): boolean;

  declare var TextDocumentItem: {
    create: typeof TextDocumentItem$create,
    is: typeof TextDocumentItem$is,
  };

  declare var CompletionItemKind: {
    Text: 1,
    Method: 2,
    Function: 3,
    Constructor: 4,
    Field: 5,
    Variable: 6,
    Class: 7,
    Interface: 8,
    Module: 9,
    Property: 10,
    Unit: 11,
    Value: 12,
    Enum: 13,
    Keyword: 14,
    Snippet: 15,
    Color: 16,
    File: 17,
    Reference: 18,
  };

  declare type CompletionItemKindType =
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18;

  declare var InsertTextFormat: {
    PlainText: 1,
    Snippet: 2,
  };

  declare type InsertTextFormatType = 1 | 2;

  /**
   * A completion item represents a text snippet that is
   * proposed to complete text that is being typed.
   */
  declare interface ICompletionItem {
    /**
     * The label of this completion item. By default
     * also the text that is inserted when selecting
     * this completion.
     */
    label: string;

    /**
     * The kind of this completion item. Based of the kind
     * an icon is chosen by the editor.
     */
    kind?: CompletionItemKindType;

    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;

    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string;

    /**
     * A string that shoud be used when comparing this item
     * with other items. When `falsy` the [label](#CompletionItem.label)
     * is used.
     */
    sortText?: string;

    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the [label](#CompletionItem.label)
     * is used.
     */
    filterText?: string;

    /**
     * A string that should be inserted a document when selecting
     * this completion. When `falsy` the [label](#CompletionItem.label)
     * is used.
     */
    insertText?: string;

    /**
     * The format of the insert text. The format applies to both the `insertText` property
     * and the `newText` property of a provided `textEdit`.
     */
    insertTextFormat?: InsertTextFormatType;

    /**
     * An [edit](#TextEdit) which is applied to a document when selecting
     * this completion. When an edit is provided the value of
     * [insertText](#CompletionItem.insertText) and [range](#CompletionItem.range) is ignored.
     */
    textEdit?: TextEdit;

    /**
     * An optional array of additional [text edits](#TextEdit) that are applied when
     * selecting this completion. Edits must not overlap with the main [edit](#CompletionItem.textEdit)
     * nor with themselves.
     */
    additionalTextEdits?: TextEdit[];

    /**
     * An optional [command](#Command) that is executed after inserting this completion. Note that
     * additional modifications to the current document should be described with the
     * [additionalTextEdits](#CompletionItem.additionalTextEdits)-property.
     */
    command?: ICommand;

    /**
     * An data entry field that is preserved on a completion item between
     * a [CompletionRequest](#CompletionRequest) and a [CompletionResolveRequest]
     *(#CompletionResolveRequest)
     */
    data?: any;
  }

  /**
   * The CompletionItem namespace provides functions to deal with
   * completion items.
   */
  declare function CompletionItem$create(label: string): ICompletionItem;

  declare var CompletionItem: {
    create: typeof CompletionItem$create,
  };

  /**
   * Represents a collection of [completion items](#CompletionItem) to be presented
   * in the editor.
   */
  declare interface ICompletionList {
    /**
     * This list it not complete. Further typing results in recomputing this list.
     */
    isIncomplete: boolean;

    /**
     * The completion items.
     */
    items: CompletionItem[];
  }

  /**
   * Creates a new completion list.
   *
   * @param items The completion items.
   * @param isIncomplete The list is not complete.
   */
  declare function CompletionList$create(
    items?: Array<ICompletionItem>,
    isIncomplete?: boolean,
  ): ICompletionList;

  declare var CompletionList: {
    create: typeof CompletionList$create,
  };

  /**
   * MarkedString can be used to render human readable text. It is either a markdown string
   * or a code-block that provides a language and a code snippet. The language identifier
   * is sematically equal to the optional language identifier in fenced code blocks in GitHub
   * issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting
   *
   * The pair of a language and a value is an equivalent to markdown:
    ```${language}
    ${value}
    ```
   *
   * Note that markdown strings will be sanitized - that means html will be escaped.
  */
  declare type IMarkedString =
    | string
    | {
        language: string,
        value: string,
      };

  /**
   * Creates a marked string from plain text.
   * @param plainText The plain text.
   */
  declare function MarkedString$fromPlainText(plainText: string): IMarkedString;

  /**
   * The result of a hover request.
   */
  declare interface Hover {
    /**
     * The hover's content
     */
    contents: IMarkedString | IMarkedString[];

    /**
     * An optional range
     */
    range?: IRange;
  }

  declare var MarkedString: {
    fromPlainText: typeof MarkedString$fromPlainText,
  };

  /**
   * Represents a parameter of a callable-signature. A parameter can
   * have a label and a doc-comment.
   */
  declare interface IParameterInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;

    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string;
  }

  /**
   * Creates a new parameter information literal.
   *
   * @param label A label string.
   * @param documentation A doc string.
   */
  declare function ParameterInformation$create(
    label: string,
    documentation?: string,
  ): IParameterInformation;

  declare var ParameterInformation: {
    create: typeof ParameterInformation$create,
  };

  /**
   * Represents the signature of something callable. A signature
   * can have a label, like a function-name, a doc-comment, and
   * a set of parameters.
   */
  declare interface ISignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;

    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string;

    /**
     * The parameters of this signature.
     */
    parameters?: IParameterInformation[];
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function SignatureInformation$create(
    label: string,
    documentation?: string,
    ...parameters: Array<IParameterInformation>
  ): ISignatureInformation;

  declare var SignatureInformation: {
    create: typeof SignatureInformation$create,
  };

  /**
   * Signature help represents the signature of something
   * callable. There can be multiple signature but only one
   * active and only one active parameter.
   */
  declare interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: Array<ISignatureInformation>;

    /**
     * The active signature.
     */
    activeSignature: number;

    /**
     * The active parameter of the active signature.
     */
    activeParameter: number;
  }

  /**
   * The definition of a symbol represented as one or many [locations](#Location).
   * For most programming languages there is only one location at which a symbol is
   * defined.
   */
  declare export type Definition = ILocation | ILocation[];

  /**
   * Value-object that contains additional information when
   * requesting references.
   */
  declare interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
  }

  declare var DocumentHighlightKind: {
    Text: 1,
    Read: 2,
    Write: 3,
  };

  declare type DocumentHighlightKindType = 1 | 2 | 3;
  /**
   * A document highlight is a range inside a text document which deserves
   * special attention. Usually a document highlight is visualized by changing
   * the background color of its range.
   */
  declare interface IDocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: IRange;

    /**
     * The highlight kind, default is [text](#DocumentHighlightKind.Text).
     */
    kind?: DocumentHighlightKindType;
  }

  /**
   * Create a DocumentHighlight object.
   * @param range The range the highlight applies to.
   */
  declare function DocumentHighlight$create(
    range: IRange,
    kind?: DocumentHighlightKindType,
  ): IDocumentHighlight;

  declare var DocumentHighlight: {
    create: typeof DocumentHighlight$create,
  };

  declare var SymbolKind: {
    File: 1,
    Module: 2,
    Namespace: 3,
    Package: 4,
    Class: 5,
    Method: 6,
    Property: 7,
    Field: 8,
    Constructor: 9,
    Enum: 10,
    Interface: 11,
    Function: 12,
    Variable: 13,
    Constant: 14,
    String: 15,
    Number: 16,
    Boolean: 17,
    Array: 18,
  };

  declare type SymbolKindType =
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18;

  /**
   * Represents information about programming constructs like variables, classes,
   * interfaces etc.
   */
  declare interface ISymbolInformation {
    /**
     * The name of this symbol.
     */
    name: string;

    /**
     * The kind of this symbol.
     */
    kind: SymbolKindType;

    /**
     * The location of this symbol.
     */
    location: ILocation;

    /**
     * The name of the symbol containing this symbol.
     */
    containerName?: string;
  }

  /**
   * Creates a new symbol information literal.
   *
   * @param name The name of the symbol.
   * @param kind The kind of the symbol.
   * @param range The range of the location of the symbol.
   * @param uri The resource of the location of symbol, defaults to the current document.
   * @param containerName The name of the symbol containg the symbol.
   */
  declare function SymbolInformation$create(
    name: string,
    kind: SymbolKindType,
    range: IRange,
    uri?: string,
    containerName?: string,
  ): ISymbolInformation;

  declare var SymbolInformation: {
    create: typeof SymbolInformation$create,
  };

  /**
   * Parameters for a [DocumentSymbolRequest](#DocumentSymbolRequest).
   */
  declare export interface DocumentSymbolParams {
    /**
     * The text document.
     */
    textDocument: TextDocumentIdentifier;
  }

  /**
   * The parameters of a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).
   */
  declare interface WorkspaceSymbolParams {
    /**
     * A non-empty query string
     */
    query: string;
  }

  /**
   * Contains additional diagnostic information about the context in which
   * a [code action](#CodeActionProvider.provideCodeActions) is run.
   */
  declare interface ICodeActionContext {
    /**
     * An array of diagnostics.
     */
    diagnostics: Array<IDiagnostic>;
  }

  /**
   * Creates a new CodeActionContext literal.
   */
  declare function CodeActionContext$create(
    diagnostics: Array<IDiagnostic>,
  ): ICodeActionContext;

  /**
   * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
   */
  declare function CodeActionContext$is(value: any): boolean;

  declare var CodeActionContext: {
    create: typeof CodeActionContext$create,
    is: typeof CodeActionContext$is,
  };

  /**
   * A code lens represents a [command](#Command) that should be shown along with
   * source text, like the number of references, a way to run tests, etc.
   *
   * A code lens is _unresolved_ when no command is associated to it. For performance
   * reasons the creation of a code lens and resolving should be done to two stages.
   */
  declare interface ICodeLens {
    /**
     * The range in which this code lens is valid. Should only span a single line.
     */
    range: IRange;

    /**
     * The command this code lens represents.
     */
    command?: ICommand;

    /**
     * An data entry field that is preserved on a code lens item between
     * a [CodeLensRequest](#CodeLensRequest) and a [CodeLensResolveRequest]
     * (#CodeLensResolveRequest)
     */
    data?: any;
  }

  /**
   * Creates a new CodeLens literal.
   */
  declare function CodeLens$create(range: IRange, data?: any): ICodeLens;

  /**
   * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
   */
  declare function CodeLens$is(value: any): boolean;

  /**
   * Value-object describing what options formatting should use.
   */
  declare interface IFormattingOptions {
    [key: string]: boolean | number | string;
    /**
     * Size of a tab in spaces.
     */
    tabSize: number;

    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
  }

  declare var CodeLens: {
    create: typeof CodeLens$create,
    is: typeof CodeLens$is,
  };

  /**
   * Creates a new FormattingOptions literal.
   */
  declare function FormattingOptions$create(
    tabSize: number,
    insertSpaces: boolean,
  ): IFormattingOptions;

  /**
   * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
   */
  declare function FormattingOptions$is(value: any): boolean;

  declare var FormattingOptions: {
    create: typeof FormattingOptions$create,
    is: typeof FormattingOptions$is,
  };

  /**
   * A document link is a range in a text document that links to an internal or external resource, like another
   * text document or a web site.
   */
  declare class DocumentLink {
    /**
     * Creates a new DocumentLink literal.
     */
    static create(range: IRange, target?: string): DocumentLink;

    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    static is(value: any): boolean;

    /**
     * The range this link applies to.
     */
    range: IRange;

    /**
     * The uri this link points to.
     */
    target: string;
  }

  declare var EOL: ['\n', '\r\n', '\r'];

  /**
   * A simple text document. Not to be implemenented.
   */
  declare interface ITextDocument {
    /**
     * The associated URI for this document. Most documents have the __file__-scheme, indicating that they
     * represent files on disk. However, some documents may have other schemes indicating that they are not
     * available on disk.
     * @readonly
     */
    uri: string;

    /**
     * The identifier of the language associated with this document.
     * @readonly
     */
    languageId: string;

    /**
     * The version number of this document (it will strictly increase after each
     * change, including undo/redo).
     * @readonly
     */
    version: number;

    /**
     * Get the text of this document.
     * @return  The text of this document.
     */
    getText(): string;

    /**
     * Converts a zero-based offset to a position.
     * @param offset A zero-based offset.
     * @return  A valid [position](#Position).
     */
    positionAt(offset: number): IPosition;

    /**
     * Converts the position to a zero-based offset.
     *
     * The position will be [adjusted](#TextDocument.validatePosition).
     * @param position A position.
     * @return  A valid zero-based offset.
     */
    offsetAt(position: IPosition): number;

    /**
     * The number of lines in this document.
     * @readonly
     */
    lineCount: number;
  }

  /**
   * Creates a new ITextDocument literal from the given uri and content.
   * @param uri The document's uri.
   * @param languageId  The document's language Id.
   * @param content The document's content.
   */
  declare function TextDocument$create(
    uri: string,
    languageId: string,
    version: number,
    content: string,
  ): ITextDocument;

  /**
   * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
   */
  declare function TextDocument$is(value: any): boolean;

  declare var TextDocument: {
    create: typeof TextDocument$create,
    is: typeof TextDocument$is,
  };

  /**
   * An event describing a change to a text document. If range and rangeLength are omitted
   * the new text is considered to be the full content of the document.
   */
  declare interface ITextDocumentContentChangeEvent {
    /**
     * The range of the document that changed.
     */
    range?: IRange;

    /**
     * The length of the range that got replaced.
     */
    rangeLength?: number;

    /**
     * The new text of the document.
     */
    text: string;
  }

  /**
   * Event to signal changes to a simple text document.
   */
  declare interface TextDocumentChangeEvent {
    /**
     * The document that has changed.
     */
    document: ITextDocument;
  }

  declare var TextDocumentSaveReason: {
    Manual: 1,
    AfterDelay: 2,
    FocusOut: 3,
  };
  declare type TextDocumentSaveReasonType = 1 | 2 | 3;

  declare interface TextDocumentWillSaveEvent {
    /**
     * The document that will be saved
     */
    document: ITextDocument;

    /**
     * The reason why save was triggered.
     */
    reason: TextDocumentSaveReasonType;
  }
}
