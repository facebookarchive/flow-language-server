/**
 * Flowtype definitions for vscode-languageserver
 * Originally Generated by Flowgen from a Typescript Definition
 */

declare module 'vscode-languageserver-types' {
  /**
   * Position in a text document expressed as zero-based line and character offset.
   */
  declare interface Position {
    /**
     * Line position in a document (zero-based).
     */
    line: number,

    /**
     * Character offset on a line in a document (zero-based). Assuming that the line is
     * represented as a string, the `character` value represents the gap between the
     * `character` and `character + 1`. Given the following line: 'aêêÄc', character 0 is
     * the gap between the start of the start and 'a' ('|aêêÄc'), character 1 is the gap
     * between 'a' and 'êêÄ' ('a|êêÄc') and character 2 is the gap between 'êêÄ' and 'b' ('aêêÄ|c').
     *
     * The string 'aêêÄc' consist of 3 characters with valid character values being 0, 1, 2, 3
     * for that string. Note that the string encoded in UTF-16 is encoded using 4 code units
     * (the êêÄ is encoded using two code units). The character offset is therefore encoding
     * independent.
     */
    character: number,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Position$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Position$is(value: any): Position;

  declare var npm$namespace$Position: {
    create: typeof Position$create,
    is: typeof Position$is,
  };

  /**
   * A range in a text document expressed as (zero-based) start and end positions.
   */
  declare interface Range {
    /**
       * The range's start position
       */
    start: Position,

    /**
           * The range's end position
           */
    end: Position,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Range$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Range$is(value: any): Position;

  declare var npm$namespace$Range: {
    create: typeof Range$create,
    is: typeof Range$is,
  };

  /**
   * Represents a location inside a resource, such as a line
   * inside a text file.
   */
  declare interface Location {
    uri: string,
    range: Range,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Location$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Location$is(value: any): Position;

  declare var npm$namespace$Location: {
    create: typeof Location$create,
    is: typeof Location$is,
  };

  declare var DiagnosticSeverity: {
    Error: 1,
    Warning: 2,
    Information: 3,
    Hint: 4,
  };

  declare type DiagnosticSeverityType = 1 | 2 | 3 | 4;

  /**
   * Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
   * are only valid in the scope of a resource.
   */
  declare interface Diagnostic {
    /**
     * The range at which the message applies
     */
    range: Range,

    /**
     * The diagnostic's severity. Can be omitted. If omitted it is up to the
     * client to interpret diagnostics as error, warning, info or hint.
     */
    severity?: DiagnosticSeverityType,

    /**
     * The diagnostic's code. Can be omitted.
     */
    code?: number | string,

    /**
     * A human-readable string describing the source of this
     * diagnostic, e.g. 'typescript' or 'super lint'.
     */
    source?: string,

    /**
     * The diagnostic's message.
     */
    message: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Diagnostic$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Diagnostic$is(value: any): Position;

  declare var npm$namespace$Diagnostic: {
    create: typeof Diagnostic$create,
    is: typeof Diagnostic$is,
  };

  /**
   * Represents a reference to a command. Provides a title which
   * will be used to represent a command in the UI and, optionally,
  an array of arguments which will be passed to the command handler
  function when invoked.
  */
  declare interface Command {
    /**
       * Title of the command, like `save`.
       */
    title: string,

    /**
           * The identifier of the actual command handler.
           */
    command: string,

    /**
           * Arguments that the command handler should be
           * invoked with.
           */
    arguments?: any[],
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function Command$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function Command$is(value: any): Position;

  declare var npm$namespace$Command: {
    create: typeof Command$create,
    is: typeof Command$is,
  };

  /**
   * A text edit applicable to a text document.
   */
  declare interface TextEdit {
    /**
       * The range of the text document to be manipulated. To insert
       * text into a document create a range where start === end.
       */
    range: Range,

    /**
           * The string to be inserted. For delete operations use an
           * empty string.
           */
    newText: string,
  }

  /**
   * Creates a replace text edit.
   * @param range The range of text to be replaced.
   * @param newText The new text.
   */
  declare function TextEdit$replace(range: Range, newText: string): TextEdit;

  /**
   * Creates a insert text edit.
   * @param psotion The position to insert the text at.
   * @param newText The text to be inserted.
   */
  declare function TextEdit$insert(
    position: Position,
    newText: string,
  ): TextEdit;

  /**
   * Creates a delete text edit.
   * @param range The range of text to be deleted.
   */
  declare function TextEdit$del(range: Range): TextEdit;

  declare var npm$namespace$TextEdit: {
    replace: typeof TextEdit$replace,
    insert: typeof TextEdit$insert,
    del: typeof TextEdit$del,
  };

  /**
   * Describes textual changes on a text document.
   */
  declare interface TextDocumentEdit {
    /**
       * The text document to change.
       */
    textDocument: VersionedTextDocumentIdentifier,

    /**
           * The edits to be applied.
           */
    edits: TextEdit[],
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function TextDocumentEdit$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function TextDocumentEdit$is(value: any): Position;

  declare var npm$namespace$TextDocumentEdit: {
    create: typeof TextDocumentEdit$create,
    is: typeof TextDocumentEdit$is,
  };

  /**
   * A workspace edit represents changes to many resources managed in the workspace. The edit
   * should either provide `changes` or `documentChanges`. If documentChanges are present
  they are preferred over `changes` if the client can handle versioned document edits.
  */
  declare interface WorkspaceEdit {
    /**
       * Holds changes to existing resources.
       */
    changes?: {
      [uri: string]: TextEdit[],
    },

    /**
           * An array of `TextDocumentEdit`s to express changes to specific a specific
           * version of a text document. Whether a client supports versioned document
          edits is expressed via `WorkspaceClientCapabilites.versionedWorkspaceEdit`.
          */
    documentChanges?: TextDocumentEdit[],
  }
  /**
   * A change to capture text edits for existing resources.
   */
  declare interface TextEditChange {
    /**
       * Gets all text edits for this change.
       * @return  An array of text edits.
       */
    all(): TextEdit[],

    /**
           * Clears the edits for this change.
           */
    clear(): void,

    /**
           * Adds a text edit.
           * @param edit the text edit to add.
           */
    add(edit: TextEdit): void,

    /**
           * Insert the given text at the given position.
           * @param position A position.
           * @param newText A string.
           */
    insert(position: Position, newText: string): void,

    /**
           * Replace the given range with given text for the given resource.
           * @param range A range.
           * @param newText A string.
           */
    replace(range: Range, newText: string): void,

    /**
           * Delete the text at the given range.
           * @param range A range.
           */
    delete(range: Range): void,
  }
  /**
   * A workspace change helps constructing changes to a workspace.
   */
  declare class WorkspaceChange {
    constructor(workspaceEdit?: WorkspaceEdit): this,

    /**
       * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
       * use to be returned from a workspace edit operation like rename.
       */
    edit: WorkspaceEdit,

    /**
       * Returns the [TextEditChange](#TextEditChange) to manage text edits
       * for resources.
       */
    getTextEditChange(
      textDocument: VersionedTextDocumentIdentifier,
    ): TextEditChange,
    getTextEditChange(uri: string): TextEditChange,
  }
  /**
   * A literal to identify a text document in the client.
   */
  declare interface TextDocumentIdentifier {
    /**
     * The text document's uri.
     */
    uri: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function TextDocumentIdentifier$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function TextDocumentIdentifier$is(value: any): Position;

  declare var npm$namespace$TextDocumentIdentifier: {
    create: typeof TextDocumentIdentifier$create,
    is: typeof TextDocumentIdentifier$is,
  };

  /**
   * An identifier to denote a specific version of a text document.
   */
  declare type VersionedTextDocumentIdentifier = {
    /**
     * The version number of this document.
     */
    version: number,
  } & TextDocumentIdentifier;

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function VersionedTextDocumentIdentifier$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function VersionedTextDocumentIdentifier$is(value: any): Position;

  declare var npm$namespace$VersionedTextDocumentIdentifier: {
    create: typeof VersionedTextDocumentIdentifier$create,
    is: typeof VersionedTextDocumentIdentifier$is,
  };

  /**
   * An item to transfer a text document from the client to the
   * server.
   */
  declare interface TextDocumentItem {
    /**
       * The text document's uri.
       */
    uri: string,

    /**
     * The text document's language identifier
     */
    languageId: string,

    /**
     * The version number of this document (it will strictly increase after each
     * change, including undo/redo).
     */
    version: number,

    /**
     * The content of the opened text document.
     */
    text: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function TextDocumentItem$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function TextDocumentItem$is(value: any): Position;

  declare var npm$namespace$TextDocumentItem: {
    create: typeof TextDocumentItem$create,
    is: typeof TextDocumentItem$is,
  };

  declare var CompletionItemKind: {
    Text: 1,
    Method: 2,
    Function: 3,
    Constructor: 4,
    Field: 5,
    Variable: 6,
    Class: 7,
    Interface: 8,
    Module: 9,
    Property: 10,
    Unit: 11,
    Value: 12,
    Enum: 13,
    Keyword: 14,
    Snippet: 15,
    Color: 16,
    File: 17,
    Reference: 18,
  };

  declare type CompletionItemKindType =
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18;

  declare var InsertTextFormat: {
    PlainText: 1,
    Snippet: 2,
  };

  declare type InsertTextFormatType = 1 | 2;

  /**
   * A completion item represents a text snippet that is
   * proposed to complete text that is being typed.
   */
  declare interface CompletionItem {
    /**
       * The label of this completion item. By default
       * also the text that is inserted when selecting
      this completion.
      */
    label: string,

    /**
           * The kind of this completion item. Based of the kind
           * an icon is chosen by the editor.
           */
    kind?: CompletionItemKind,

    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string,

    /**
           * A human-readable string that represents a doc-comment.
           */
    documentation?: string,

    /**
           * A string that shoud be used when comparing this item
           * with other items. When `falsy` the [label](#CompletionItem.label)
          is used.
          */
    sortText?: string,

    /**
           * A string that should be used when filtering a set of
           * completion items. When `falsy` the [label](#CompletionItem.label)
          is used.
          */
    filterText?: string,

    /**
           * A string that should be inserted a document when selecting
           * this completion. When `falsy` the [label](#CompletionItem.label)
          is used.
          */
    insertText?: string,

    /**
     * The format of the insert text. The format applies to both the `insertText` property
     * and the `newText` property of a provided `textEdit`.
     */
    insertTextFormat?: InsertTextFormatType,

    /**
     * An [edit](#TextEdit) which is applied to a document when selecting
     * this completion. When an edit is provided the value of
     * [insertText](#CompletionItem.insertText) and [range](#CompletionItem.range) is ignored.
     */
    textEdit?: TextEdit,

    /**
     * An optional array of additional [text edits](#TextEdit) that are applied when
     * selecting this completion. Edits must not overlap with the main [edit](#CompletionItem.textEdit)
     * nor with themselves.
     */
    additionalTextEdits?: TextEdit[],

    /**
     * An optional [command](#Command) that is executed after inserting this completion. Note that
     * additional modifications to the current document should be described with the
     * [additionalTextEdits](#CompletionItem.additionalTextEdits)-property.
     */
    command?: Command,

    /**
     * An data entry field that is preserved on a completion item between
     * a [CompletionRequest](#CompletionRequest) and a [CompletionResolveRequest]
     *(#CompletionResolveRequest)
     */
    data?: any,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function CompletionItem$create(
    line: number,
    character: number,
  ): Position;

  declare var npm$namespace$CompletionItem: {
    create: typeof CompletionItem$create,
  };

  /**
   * Represents a collection of [completion items](#CompletionItem) to be presented
   * in the editor.
   */
  declare interface CompletionList {
    /**
       * This list it not complete. Further typing results in recomputing this list.
       */
    isIncomplete: boolean,

    /**
           * The completion items.
           */
    items: CompletionItem[],
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function CompletionList$create(
    line: number,
    character: number,
  ): Position;

  declare var npm$namespace$CompletionList: {
    create: typeof CompletionList$create,
  };

  /**
   * MarkedString can be used to render human readable text. It is either a markdown string
   * or a code-block that provides a language and a code snippet. The language identifier
  is sematically equal to the optional language identifier in fenced code blocks in GitHub
  issues. See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting

  The pair of a language and a value is an equivalent to markdown:
  ```${language}
  ${value}
  ```

  Note that markdown strings will be sanitized - that means html will be escaped.
  */
  declare type MarkedString =
    | string
    | {
        language: string,
        value: string,
      };

  /**
   * Creates a marked string from plain text.
   * @param plainText The plain text.
   */
  declare function MarkedString$fromPlainText(plainText: string): MarkedString;
  /**
   * The result of a hover request.
   */
  declare interface Hover {
    /**
     * The hover's content
     */
    contents: MarkedString | MarkedString[],

    /**
     * An optional range
     */
    range?: Range,
  }

  declare var npm$namespace$MarkedString: {
    fromPlainText: typeof MarkedString$fromPlainText,
  };

  /**
   * Represents a parameter of a callable-signature. A parameter can
   * have a label and a doc-comment.
   */
  declare interface ParameterInformation {
    /**
       * The label of this signature. Will be shown in
       * the UI.
       */
    label: string,

    /**
           * The human-readable doc-comment of this signature. Will be shown
           * in the UI but can be omitted.
           */
    documentation?: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function ParameterInformation$create(
    line: number,
    character: number,
  ): Position;
  /**
   * Represents the signature of something callable. A signature
   * can have a label, like a function-name, a doc-comment, and
  a set of parameters.
  */
  declare interface SignatureInformation {
    /**
       * The label of this signature. Will be shown in
       * the UI.
       */
    label: string,

    /**
           * The human-readable doc-comment of this signature. Will be shown
           * in the UI but can be omitted.
           */
    documentation?: string,

    /**
           * The parameters of this signature.
           */
    parameters?: ParameterInformation[],
  }

  declare var npm$namespace$ParameterInformation: {
    create: typeof ParameterInformation$create,
  };

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function SignatureInformation$create(
    line: number,
    character: number,
  ): Position;

  declare var npm$namespace$SignatureInformation: {
    create: typeof SignatureInformation$create,
  };

  /**
   * Signature help represents the signature of something
   * callable. There can be multiple signature but only one
  active and only one active parameter.
  */
  declare interface SignatureHelp {
    /**
       * One or more signatures.
       */
    signatures: SignatureInformation[],

    /**
           * The active signature.
           */
    activeSignature: number,

    /**
           * The active parameter of the active signature.
           */
    activeParameter: number,
  }
  /**
   * The definition of a symbol represented as one or many [locations](#Location).
   * For most programming languages there is only one location at which a symbol is
  defined.
  */
  declare type Definition = Location | Location[];
  /**
   * Value-object that contains additional information when
   * requesting references.
   */
  declare interface ReferenceContext {
    /**
       * Include the declaration of the current symbol.
       */
    includeDeclaration: boolean,
  }
  declare var Text: 1;

  declare var Read: 2;

  declare var Write: 3;
  declare type DocumentHighlightKind = 1 | 2 | 3;
  /**
   * A document highlight is a range inside a text document which deserves
   * special attention. Usually a document highlight is visualized by changing
  the background color of its range.
  */
  declare interface DocumentHighlight {
    /**
       * The range this highlight applies to.
       */
    range: Range,

    /**
           * The highlight kind, default is [text](#DocumentHighlightKind.Text).
           */
    kind?: DocumentHighlightKind,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function DocumentHighlight$create(
    line: number,
    character: number,
  ): Position;

  declare var npm$namespace$DocumentHighlight: {
    create: typeof DocumentHighlight$create,
  };

  declare var SymbolKind: {
    File: 1,
    Module: 2,
    Namespace: 3,
    Package: 4,
    Class: 5,
    Method: 6,
    Property: 7,
    Field: 8,
    Constructor: 9,
    Enum: 10,
    Interface: 11,
    Function: 12,
    Variable: 13,
    Constant: 14,
    String: 15,
    Number: 16,
    Boolean: 17,
    Array: 18,
  }

  declare type SymbolKindType =
    | 1
    | 2
    | 3
    | 4
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18;
  /**
   * Represents information about programming constructs like variables, classes,
   * interfaces etc.
   */
  declare interface SymbolInformation {
    /**
     * The name of this symbol.
     */
    name: string,

    /**
     * The kind of this symbol.
     */
    kind: SymbolKind,

    /**
     * The location of this symbol.
     */
    location: Location,

    /**
     * The name of the symbol containing this symbol.
     */
    containerName?: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function SymbolInformation$create(
    line: number,
    character: number,
  ): Position;

  declare var npm$namespace$SymbolInformation: {
    create: typeof SymbolInformation$create,
  };

  /**
   * Parameters for a [DocumentSymbolRequest](#DocumentSymbolRequest).
   */
  declare interface DocumentSymbolParams {
    /**
       * The text document.
       */
    textDocument: TextDocumentIdentifier,
  }
  /**
   * The parameters of a [WorkspaceSymbolRequest](#WorkspaceSymbolRequest).
   */
  declare interface WorkspaceSymbolParams {
    /**
     * A non-empty query string
     */
    query: string,
  }
  /**
   * Contains additional diagnostic information about the context in which
   * a [code action](#CodeActionProvider.provideCodeActions) is run.
   */
  declare interface CodeActionContext {
    /**
     * An array of diagnostics.
     */
    diagnostics: Diagnostic[],
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function CodeActionContext$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function CodeActionContext$is(value: any): Position;

  declare var npm$namespace$CodeActionContext: {
    create: typeof CodeActionContext$create,
    is: typeof CodeActionContext$is,
  };

  /**
   * A code lens represents a [command](#Command) that should be shown along with
   * source text, like the number of references, a way to run tests, etc.

  A code lens is _unresolved_ when no command is associated to it. For performance
  reasons the creation of a code lens and resolving should be done to two stages.
  */
  declare interface CodeLens {
    /**
       * The range in which this code lens is valid. Should only span a single line.
       */
    range: Range,

    /**
           * The command this code lens represents.
           */
    command?: Command,

    /**
           * An data entry field that is preserved on a code lens item between
           * a [CodeLensRequest](#CodeLensRequest) and a [CodeLensResolveRequest]
          (#CodeLensResolveRequest)
          */
    data?: any,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function CodeLens$create(line: number, character: number): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function CodeLens$is(value: any): Position;
  /**
   * Value-object describing what options formatting should use.
   */
  declare interface FormattingOptions {
    [key: string]: boolean | number | string,
    /**
       * Size of a tab in spaces.
       */
    tabSize: number,

    /**
           * Prefer spaces over tabs.
           */
    insertSpaces: boolean,
  }

  declare var npm$namespace$CodeLens: {
    create: typeof CodeLens$create,
    is: typeof CodeLens$is,
  };

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function FormattingOptions$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function FormattingOptions$is(value: any): Position;

  declare var npm$namespace$FormattingOptions: {
    create: typeof FormattingOptions$create,
    is: typeof FormattingOptions$is,
  };

  /**
   * A document link is a range in a text document that links to an internal or external resource, like another
   * text document or a web site.
   */
  declare class DocumentLink {
    /**
       * The range this link applies to.
       */
    range: Range,

    /**
       * The uri this link points to.
       */
    target: string,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function DocumentLink$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function DocumentLink$is(value: any): Position;

  declare var npm$namespace$DocumentLink: {
    create: typeof DocumentLink$create,
    is: typeof DocumentLink$is,
  };

  declare var EOL: string[];
  /**
   * A simple text document. Not to be implemenented.
   */
  declare interface TextDocument {
    /**
     * The associated URI for this document. Most documents have the __file__-scheme, indicating that they
     * represent files on disk. However, some documents may have other schemes indicating that they are not
     * available on disk.
     * @readonly
    */
    uri: string,

    /**
     * The identifier of the language associated with this document.
     * @readonly
     */
    languageId: string,

    /**
     * The version number of this document (it will strictly increase after each
     * change, including undo/redo).
     * @readonly
     */
    version: number,

    /**
     * Get the text of this document.
     * @return  The text of this document.
     */
    getText(): string,

    /**
     * Converts a zero-based offset to a position.
     * @param offset A zero-based offset.
     * @return  A valid [position](#Position).
     */
    positionAt(offset: number): Position,

    /**
     * Converts the position to a zero-based offset.
     *
     * The position will be [adjusted](#TextDocument.validatePosition).
     * @param position A position.
     * @return  A valid zero-based offset.
    */
    offsetAt(position: Position): number,

    /**
           * The number of lines in this document.
           * @readonly
           */
    lineCount: number,
  }

  /**
   * Creates a new Position literal from the given line and character.
   * @param line The position's line.
   * @param character The position's character.
   */
  declare function TextDocument$create(
    line: number,
    character: number,
  ): Position;

  /**
   * Checks whether the given liternal conforms to the [Position](#Position) interface.
   */
  declare function TextDocument$is(value: any): Position;

  declare var npm$namespace$TextDocument: {
    create: typeof TextDocument$create,
    is: typeof TextDocument$is,
  };

  /**
   * Event to signal changes to a simple text document.
   */
  declare interface TextDocumentChangeEvent {
    /**
       * The document that has changed.
       */
    document: TextDocument,
  }
  declare var Manual: 1;

  declare var AfterDelay: 2;

  declare var FocusOut: 3;
  declare type TextDocumentSaveReason = 1 | 2 | 3;
  declare interface TextDocumentWillSaveEvent {
    /**
       * The document that will be saved
       */
    document: TextDocument,

    /**
           * The reason why save was triggered.
           */
    reason: TextDocumentSaveReason,
  }
  /**
   * An event describing a change to a text document. If range and rangeLength are omitted
   * the new text is considered to be the full content of the document.
   */
  declare interface TextDocumentContentChangeEvent {
    /**
       * The range of the document that changed.
       */
    range?: Range,

    /**
           * The length of the range that got replaced.
           */
    rangeLength?: number,

    /**
           * The new text of the document.
           */
    text: string,
  }
}
